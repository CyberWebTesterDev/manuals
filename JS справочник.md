JavaScript справочник
=================

# Основные моменты

JavaScript - однопоточный (один стек вызовов) (однако, в некотором контексте можно считать, что у него есть более одного потока) интерпретируемый (исполняется на ходу) язык программирования, в основном событийно-ориентированного типа с инструментами ООП и со значительном функционально-ориентированным уклоном.


## Движки JavaScript

Краткие сведения в движках JS.

JavaScript-движок — это программа, или, другими словами, интерпретатор, выполняющий код, написанный на JavaScript. Движок может быть реализован с использованием различных подходов: в виде обычного интерпретатора, в виде динамического компилятора (или JIT-компилятора), который, перед выполнением программы, преобразует исходный код на JS в байт-код некоего формата.

Наиболее популярные JS-движки: V8 (Google), Rhino (Mozilla Foundation), SpiderMonkey (Firefox)


## Цикл событий | Event Loop

Код в JavaScript исполняется в режиме Event Loop. Т.е. в один из моментов времени может выполняться только одна операция, остальные же ждут своей очереди в так называемом цикле событий Event Loop. В момент исполнения определенной функции она блокирует работу остальных, поэтому часто, когда функция ожидает, например, ответа от стороннего сервера в JS-приложениях используют асинхронные функции, т.е. работа приложения не блокируется, а функция ожидающая ответа продолжит свое выполнение после того как получит ответ. Таким образом, в некий момент времени он может выполнять лишь какую-то одну задачу.

Код JS не исполняется в изоляции. Его собственный код выполняется внутри некоего окружения, которым, для большинства разработчиков, является либо браузер, либо Node.js.

Движок JavaScript. V8 от Google — это широко известный JS-движок. Он используется, например, в браузере Chrome и в Node.js. Вот как его, очень упрощённо, можно представить:

* Heap (куча) — то место, где происходит выделение памяти.
* Стек вызовов (Call Stack) — то место, куда в процессе выполнения кода попадают так называемые стековые кадры.

Стек вызовов — это структура данных, которая, говоря упрощённо, записывает сведения о месте в программе, где мы находимся. Если мы переходим в функцию, мы помещаем запись о ней в верхнюю часть стека. Когда мы из функции возвращаемся, мы вытаскиваем из стека самый верхний элемент и оказываемся там, откуда вызывали эту функцию. Это — всё, что умеет стек.

Например, возьмем следующий блок кода:
```javascript
function multiply(x, y) {
    return x * y;
}
function printSquare(x) {
    const s = multiply(x, x);
    console.log(s);
}
printSquare(5);
```
Когда движок только начинает выполнять этот код, стек вызовов пуст. После этого происходит следующее:

* Step 1: printSquare(5) *(вызывали функцию)*
* Step 2: printSquare(5): multiply(x, x) *(вызвали вложенную функцию, при этом находимся в исполнении функции printSquare)*
* Step 3: printSquare(5): console.log(s) *(вызвали вложенную функцию, при этом находимся в исполнении функции printSquare)*
* Step 4: printSquare(5) *(вернулись из фунции printSquare)*
* Step 5: *(перешли в блок кода после функции)*

Каждая запись (в примере выше Step) в стеке вызовов называется стековым кадром.

На механизме анализа стековых кадров основана информация о стеке вызовов, трассировка стека, выдаваемая при возникновении исключения. Трассировка стека представляет собой состояние стека в момент исключения.

Если будет достигнут максимальный размер стека, возникнет так называемое переполнение стека. Произойти такое может довольно просто, например, при необдуманном использовании рекурсии. Взгляните на этот фрагмент кода:
```javascript
function foo() {
    foo();
}
foo();
```
Когда движок приступает к выполнению этого кода, всё начинается с вызова функции foo. Это — рекурсивная функция, которая не содержит условия прекращения рекурсии. Она бесконтрольно вызывает сама себя. В результате на каждом шаге выполнения в стек вызовов снова и снова добавляется информация об одной и той же функции.

В определённый момент, однако, объём данных о вызовах функции превысит размер стека вызовов и браузер решит вмешаться, выдав ошибку:
`Uncaught RangeError: Maximum call stack size exceeded`


Что происходит, когда в стеке вызовов имеется функция, на выполнение которой нужно очень много времени? Например, представьте, что вам надо выполнить какое-то сложно преобразование изображения с помощью JavaScript в браузере.

«А в чём тут проблема?», — спросите вы. Проблема заключается в том, что до тех пор, пока в стеке вызовов имеется выполняющаяся функция, браузер не может выполнять другие задачи — он оказывается заблокированным. Это означает, что браузер не может выводить ничего на экран, не может выполнять другой код. Он просто останавливается. Подобные эффекты, например, несовместимы с интерактивными интерфейсами.

Общей характеристикой всех подобных сред является встроенный механизм, который называется циклом событий (event loop). Он поддерживает выполнение фрагментов программы, вызывая для этого JS-движок.

Итак, как же выполнять тяжёлые вычисления, не блокируя пользовательский интерфейс и не подвешивая браузер? Решение этой проблемы заключается в использовании **асинхронных функций** обратного вызова.

## Web API

Что представляют собой Web API? В целом, это — потоки, к которым у JS-разработчика нет прямого доступа, есть возможность только выполнять обарщения к ним. Они встроены в браузер, где и выполняются асинхронные действия. На платформе Node.js подобные API реализованы посредством C++.

Например, функция `setTimeout(callback, ms)` предоставляет доступ к API браузера или среды Node.js.

Вызов `setTimeout(…)` не приводит к автоматическому размещению коллбэка в очереди цикла событий. Эта команда запускает таймер. Когда таймер срабатывает, окружение помещает коллбэк в цикл событий, в результате, в ходе какого-то из будущих тиков, этот коллбэк будет взят в работу и выполнен. Взгляните на этот фрагмент кода:

```javascript
setTimeout(myCallback, 1000);
```

Выполнение этой команды не означает, что myCallback будет выполнен через 1000 мс., правильнее будет сказать, что через 1000 мс. myCallback будет добавлен в очередь. В очереди, однако, могут быть другие события, добавленные туда ранее, в результате нашему коллбэку придётся подождать.

## Event Loop

Подробнее о цикле событий.

Цикл событий решает одну основную задачу: наблюдает за стеком вызовов и очередью коллбэков (callback queue). Если стек вызовов пуст, цикл берёт первое событие из очереди и помещает его в стек, что приводит к запуску этого события на выполнение.

Коллбэки (callback) - это функции, которая должна исполниться при наступлении определенного события (как правило после получения ответа).

Забор события из очереди и помещение его в стек - итерация, которая называется тиком (tick) цикла событий. Каждое событие просто callback.


Интересно заметить, что спецификация ES6 определяет то, как должен работать цикл событий, а именно, указывает на то, что технически он находится в пределах ответственности JS-движка, который начинает играть более важную роль в экосистеме JS. Основная причина подобного заключается в том, что в ES6 появились промисы и им требуется надёжный механизм планирования операций в очереди цикла событий.

## Задания ES6

В ES6 появилась новая концепция, которая называется очередью заданий (Job Queue). Эту конструкцию можно считать слоем, расположенным поверх очереди цикла событий. Вполне возможно, вы с ней сталкивались, когда вам приходилось разбираться с особенностями асинхронного поведения промисов.

Очередь заданий — это очередь, которая присоединена к концу каждого тика в очереди цикла событий. Некие асинхронные действия, которые могут произойти в течение тика цикла событий не приведут к тому, что новое событие будет добавлено в очередь цикла событий, но вместо этого элемент (то есть — задание) будет добавлен в конец очереди заданий текущего тика. Это означает, что добавляя в очередь команды, которые должны быть выполнены в будущем, вы можете быть уверены в том, в каком порядке они будут выполняться.


# Операторы

condition - условное выражение
expression - исполняемый блок кода

тернарный оператор:
```javascript
	condition ? true : false
```
пример:
```javascript
	let canDrive = age > 16 ? 'yes' : 'no';
```
пример с ключевым словом `return`:
```javascript
	return text.length < 5 ? false : true;
```
пример с булевым оператором &&:
```javascript

	const doIfTrue = () => {
		console.log(`doIfTrue`);
	}

		const doIfFalse = () => {
		console.log(`doIfFalse`);
	}

	//таким образом проверяем сразу как на наличие свойства объекта так на значение
	someObject.variableToCheck && someObject.variableToCheck == true ? doIfTrue() : doIfFalse();
```


## Логический оператор `&&` (логическое И):

	condition && expression

пример:
```javascript
array.length > 0 && console.log('Массив не пуст');
```
Выражение true && expression всегда вычисляется как expression, а выражение false && expression — как false.

булевый оператор `||` (логическое ИЛИ):

Выражение `Boolean(expression) || Boolean(expression2)` всегда вернет значение первого выражения, если оно равно `true`, иначе будет возвращено значение второго выражения.

пример:
```javascript
const i = 5;

return i > 7 || i > 6 //вернет false так как значение первого выражения будет вычислено как false, а второе также равно false
return i > 7 || i < 6 //вернет true так как значение первого выражения будет вычислено как false, а второе равно true
return i < 7 || i > 6 //вернет true так как значение первого выражения будет вычислено как true, значение второго при этом игнорируется
```

## Условный оператор if.

Всегда false:
```javascript
if(null), if(''), if(undefined), if(NaN), if(0)
```

## Оператор объединения ??

Оператор объединения с null представляет собой два вопросительных знака ??.

Результат выражения `a ?? b` будет следующим:

    a, если значение a определено,
    b, если значение a не определено.

То есть оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй.

Шаблонные строки или Template Literals

```javascript
	const a = 'Hello';
	const name = 'Peter';
	const greeting = `${a} + ${name}. Now is ${Date.now()}. Have a nice day!`;
	console.log(greeting);
```

## Оператор ??=

Оператор, используемый для назначения значения переменной только в том случае, если она имеет значение null или undefined.

```javascript
function myFn(variable1, variable2) {
  variable2 ??= "default value"
  return variable1 + variable2
}

myFn("this has ", "no default value") //возвращает "this has no default value"
myFn("this has no ") //возвращает "this has no default value"
myFn("this has no ", 0) //возвращает "this has no 0"
```
## Оператор !!

Данный оператор используется для вычисления логического типа стоящих справа сущностей.

```javascript
!!23 // TRUE
!!"" // FALSE
!!0 // FALSE
!!{} // TRUE
```

Один оператор ! уже решает большую часть этой задачи, то есть — преобразует значение к логическому типу, а затем возвращает противоположное значение. А второй оператор ! берёт то, что получилось, и просто возвращает значение, обратное ему. В результате мы и получаем исходное значение, преобразованное к логическому типу.

Эта короткая конструкция может оказаться полезной в различных ситуациях. Во-первых — когда нужно обеспечить присвоение некоей переменной настоящего логического значения (например, если речь идёт о TypeScript-переменной типа boolean). Во-вторых — когда нужно выполнить строгое сравнение (с помощью ===) чего-либо с true или false.

Пример использования с тернарным оператором:
```javascript
!!1 ? console.log('true condition') : console.log('false condition') // true condition
!!0 ? console.log('true condition') : console.log('false condition') // false condition
```


# Ключевые слова let и const

`const` - объявление константы. Значения констант, которые содержат данные примитивных типов (`string`, `numeric`, `boolean`) нельзя изменять, однажды присвоив.
С другой стороны если константе присвоен объект или массив, то константа не допускает переопределения на другой элемент, при этом сами вложенные элементы массива, объекта можно изменять.
`let` - объявление переменной, если ее в дальнейшем потребуется изменять.

**Важное отличие от `var`.**
Областью видимости переменных, объявленных с помощью var является вся функция или скрипт где, объявлена. `let` и `const` видны только в рамках блока кода, где они объявлены. Например:

```javascript
if(true) {
	let a = 1;
}
```
Область видимости `a` только внутри фигурных скобок.

`var` виден также вне блока `{...}` (за исключением, если это не блок функции).
```javascript
if (true) {
  var test = true; // используем var вместо let
}
alert(test); // true, переменная существует вне блока if
```
# Прототипы Prototypes

JavaScript часто описывают как язык прототипного наследования — каждый объект, имеет объект-прототип, который выступает как шаблон, от которого объект наследует методы и свойства.

Объект-прототип так же может иметь свой прототип и наследовать его свойства и методы и так далее. Это часто называется цепочкой прототипов и объясняет почему одним объектам доступны свойства и методы которые определены в других объектах.

Точнее, свойства и методы определяются в свойстве `prototype` функции-конструктора объектов, а не в самих объектах.

Когда JS движок ищет определенный набор свойств и методов какого-либо объекта сначала он обращается к самому объекту, затем по цепочке вверх к вышестоящим прототипам и так далее пока не найдет объект, у которого нет прототипа.

Пример работы прототипа:

Способ задания прототипа #1:
```javascript
	const animal = {
		say: function() {
			console.log(this.name, 'goes', this.voice);
		}
	};

	const dog = {
		name: 'dog',
		voice: 'woof'
	};
	//создаем связь между dog и animal
	Object.setPrototypeOf(dog, animal);

	const cat = {
		name: 'cat',
		voice: 'meow'
	};
	Object.setPrototypeOf(cat, animal);

	dog.say();
	cat.say();
```
Внимание! Метод `Object.setPrototypeOf()` отрицательно сказывается на производительности приложения! Оптимальнее использовать `Object.create()`


Способ задания прототипа #2:
```javascript
	const animal = {
		say: function() {
			console.log(this.name, 'goes', this.voice);
		}
	};

	const dog = Object.create(animal); //animal будет прототипом для dog
	dog.name = 'dog';
	dog.voice = 'woof';

	dog.say();

```
Способ задания прототипа #3:
```javascript
	function Animal(name, voice) {
		this.name = name;
		this.voice = voice;
	}
	//у функций объявленных ключевым словом function есть свойство prototype (изначально пустой объект)
	//запишем прототипу функции Animal свойство
	Animal.prototype.say =
		function() {
			console.log(this.name, 'goes', this.voice);
		};

	//новый объект возвращается из конструктора при вызове с ключевым словом new
	const dog = new Animal('dog', 'woof');
	const cat = new Animal('cat', 'meow');

	dog.say();
	cat.say();
```

# Работа с элементами DOM

## Node.appendChild()

`Node.appendChild()` добавляет узел в конец списка дочерних элементов указанного родительского узла. Если данный дочерний элемент является ссылкой на существующий узел в документе, то функция `appendChild()` перемещает его из текущей позиции в новую позицию (нет необходимости удалять узел из родительского узла перед добавлением его к какому-либо другому узлу).

Это означает, что узел не может находиться в двух точках документа одновременно. Поэтому, если у узла уже есть родитель, он сначала удаляется, а затем добавляется в новую позицию. `Node.cloneNode()` можно использовать для создания копии узла перед добавлением его в новый родительский элемент. Обратите внимание, что копии, сделанные с помощью `cloneNode` , не будут автоматически синхронизироваться.


Пример с копированием текста в буфер обмена

```javascript

const copyToClipBoard = (str) =>
{
    const el = document.createElement('textarea');
    el.value = str;
    document.body.appendChild(el); //добавляем дочерний элемент в узел body
    el.select(); //выделение области элемента
    document.execCommand('copy'); //копирование в буфер обмена выделенной области
    document.body.removeChild(el); //удаляем дочерний для body элемент el
};

document.querySelector(".btnCopy").addEventListener("click", function()
{
    let copyText = document.getElementById('textContainer').innerText;

    // Or...
    //var elems = document.getElementsByClassName("hl7MsgBox");
    //var copyText = elems[0].textContent;

    copyToClipBoard(copyText);
});
```

## Node.removeChild()

Удаляет дочерний элемент из DOM. Возвращает удаленный элемент.

На вход принимает элемент, который требуется удалить, в Node должен быть указан обязательно родительский элемент.

пример простого удаления:

```javascript

    const el = document.createElement('textarea'); //сначала создаем элемент с указанным типом
    document.body.appendChild(el); //добавляем ранее созданный элемент в узел body
    document.body.removeChild(el); //удаляем дочерний для body элемент el

```

пример более сложного удаления, когда неизвестен родитель требуемого к удалению элемента:

```javascript
	const targetElementToDelete = document.getElementById('temp-container'); //помещаем в переменную элемент, который необходимо удалить

	if (targetElementToDelete.parentNode) { //проверяем есть ли у элемента родительский элемент
		targetElementToDelete.parentNode.removeChild(targetElementToDelete); //получили родителя элемента и удалили его дочерний элемент
	}
```

## Node.nextSibling

Свойство `Node.nextSibling` используется только для чтения и возвращает узел, непосредственно следующий за данным узлом в списке `childNodes` его родительского элемента, или null если данный узел последний в этом списке.


## Node.childNodes

Доступный для чтения аттрибут `Node.childNodes` возвращает коллекцию `NodeList` дочерних элементов данного элемента.


Элементы в коллекции являются объектам, а не строками. Чтобы получить данные из этих объектов, вы должны использовать их свойства (например, `elementNodeReference.childNodes[1].nodeName` чтобы получить имя, и т. д.).


Пример работы с дочерними элементами, используя `childNodes`:

```javascript
		//получаем дочерние узлы в виде массива
        let thChilds = document.querySelector('#integrationLogData > tbody > tr:nth-child(1)').childNodes;

		//проходим в цикле коллекцию с использованием метода forEach
        thChilds.forEach((child, i) => {
        //при проверке обращаемся к свойству дочернего узла
          if (i > 1 && child.localName == 'th') {
            fieldNames.push(child.innerText);
          }
        });
```


## Node.children

Свойство `children` родительского узла является свойством только для чтения, которое возвращает `HTMLCollection`, содержащее все дочерние `elements` узла, на котором он был вызван.

если у узла детей нет, она будет пустой. Определить это можно, обратившись к свойству `length`, которое содержит в себе количество элементов в коллекции.

Пример работы с children:

```javascript

		//получаем коллекцию дочерних элементов
		let tdChilds = document.querySelector('#integrationLogData > tbody').children[0].children;

		//вариант обхода коллекции
        for (let td of tdChilds) {
          if (td.cellIndex == 7) {
            fieldValues.push(td.lastElementChild.innerHTML);
          } else if (td.cellIndex > 0) {
            fieldValues.push(td.innerText);
          }
        }

```


## Node.hasChildNodes()

Метод `Node.hasChildNodes()` возвращает `Boolean` значение показывающее имеет ли текущий `Node` дочерние узлы или нет.


Следующий пример удаляет первый дочерний узел внутри элемента с id "element", если element имеет дочерние узлы.

```javascript
	let element = document.getElementById("element");

	if ( element.hasChildNodes() ) {
	  element.removeChild( element.childNodes[0] );
	}
```

```javascript
	let test = document.createElement('p');
	console.log(test.isConnected); // returns false
	document.body.appendChild(test);
	console.log(test.isConnected); // returns true
```

## Node.isConnected

`isConnected` это свойство узла `Node` вмещающее в себя значение типа `Boolean`, которое зависит от того подключен ли узел (напрмую или косвенно) к какому либо объекту, например к `Document`.


## Node.insertBefore()

Метод `Node.insertBefore()` добавляет элемент в список дочерних элементов родителя перед указанным элементом.


Пример вставки:

`let insertedElement = parentElement.insertBefore(newElement, referenceElement);`

`referenceElement` элемент, перед которым будет вставлен `newElement`



## Node.textContent

Позволяет задавать или получать текстовое содержимое элемента и его потомков.



* textContent возвращает null, если узел является документом, типом документа, или его описанием. Для получения всего текста и CDATA-данных во всём документе можно использовать document.documentElement.textContent.

* Если узел является CDATA, комментарием, инструкцией, или текстовым элементом, textContent возвращает текст внутри узла в виде строки (т.н. nodeValue).

* Для узлов других типов textContent возвращает конкатенацию свойств textContent всех дочерних узлов, исключая комментарии и строки кода. Если узел не имеет дочерних узлов, будет возвращена пустая строка.

* Установка данного значения удаляет все дочерние узлы и заменяет их единичным текстовым узлом с указанным значением.

Отличие от `innerText`

`element.innerText` был введен Internet Explorer-ом. Работает по тому же принципу за небольшими исключениями:

`textContent` получает содержимое всех элементов, включая  <script/> и <style/>, тогда как innerText этого не делает.
`innerText` умеет считывать стили и не возвращает содержимое скрытых элементов, тогда как `textContent` этого не делает.
Метод `innerText` позволяет получить CSS, а `textContent` — нет.


Отличие от `innerHTML`

`innerHTML`, как можно понять из его названия, возвращает HTML. Довольно часто `innerHTML` используется для получения или записи текста в элемент. Тем не менее, вместо него желательно использовать `textContent`: этот метод потребляет гораздо меньше ресурсов, так как текст парсится как текст, а не HTML. Кроме того, это защищает от XSS атак.


## Node.contains()

Метод `Node.contains()` возвращает `Boolean` значение, указывающее, является ли узел потомком данного узла, т. е. сам узел, один из его прямых потомков ( `childNodes` ), один из детей его детей и так далее.

Эта функция проверяет, находится ли элемент в теле страницы.

```javascript
const isInPage = (node) => {
  return (node === document.body) ? false : document.body.contains(node);
}
```

## HTMLElement.style

Свойство HTMLElement.style используется для получения и установки инлайновых стилей. При получении возвращается объект CSSStyleDeclaration , который содержит список из всех свойств стилей для этого элемента с значениями заданными  для атрибутов , что определенны  в инлайновом стиле (см. атрибут стиля) элемента. См. CSS Properties Reference для получения списка CSS свойств применимых вместе со style.

Пример обращения к свойству CSS элемента

`someElement.style.color`


#Объекты

пример сокращенной записи при назначении значений свойствам объекта


```javascript
	const x = 10;
	const y = 30;

	const obj = {
		x,
		y
	};
```

создание методов в объектах без назначения имени свойству:

```javascript
	const obj = {
		x,
		y,
		draw(ctx) {
			//...
		}
	};
```


При создании объектов можно использовать имена ключей, вычисленных динамически:

```javascript
	const prefix = '_blah_';

	const data = {
		[prefix + 'name']: 'Bob',
		[prefix + 'age']: 23
	};
	console.log(data);
	//выведет {_blah_name: 'Bob', _blah_age: 23}
```
Пример объявления свойства с точкой:

```javascript
const obj2 = {
  'last_seen.time': 13525235,
    name: 'profile_first'
}
//или
const obj3 = {
  ['last_seen.time']: 13525235,
    name: 'profile_first'
}

//Обратиться к такому свойству затем для получения значения можно с помощью:

obj2['last_seen.time'];
obj3['last_seen.time'];
```
## Вычисляемые имена свойств

Начиная с ECMAScript 2015, синтаксис объявления объектов также поддерживает вычисляемые имена свойств. Это позволяет добавлять в скобки [] выражение, которое будет вычислено, как имя свойства. Пример:

```javascript
let param = 'size';
const config = {
  [param]: 12,
  ['mobile' + param.charAt(0).toUpperCase() + param.slice(1)]: 4
};

console.log(config); // {size: 12, mobileSize: 4}
```

`Object.assign()` используется для копирования значений всех собственных перечисляемых свойств из одного или более исходных объектов в целевой объект. После копирования он возвращает целевой объект.

К примеру:

```javascript
	const default = {
		host: 'localhost',
		dbName: 'blog',
		user: 'admin'
	};

	const opts = {
		user: 'john',
		password: 'utopia'
	};

	//перезапишет объект или добавит новые ключи из другого объекта
	Object.assign(defaults, opts);
	//копирует в пустой объект значения сначала из defaults, затем из opts и вернет первый аргумент, т.е. полученный новый объект. defaults и opts остаются неизменными.
	Object.assign({}, defaults, opts);

```

Пример создания shallow-копии:

```javascript
	const person = {
		name: 'Bob',
		friends: ['Mark', 'Jacob']
	};

	const shallowCopy = Object.assign({}, person);
	//shallow-копия это поверхностная копия объекта. Таким способом создается новый объект, но значения, которые мы используем в копии остаются теми же, что и в Person. Если изменить значение ключа исходного объекта, то это изменение отразится и в shallow-копии.
```

## Геттеры и сеттеры свойства-аксесоры | Getters Setters

Это особые свойства объектов. Геттеры и сеттеры это функции, который вызываются как если бы мы просто считывали свойство объекта

Пример:
```javascript
let obj = {

  value: someValue,
  get propName() {
    return `_getter_${this.someValue}`;// геттер, срабатывает при чтении obj.propName
  },

  set propName(value) {
    this.someValue += '_setter_'; // сеттер, срабатывает при записи obj.propName = value
  }
};

const x = obj.propName //обращаемся к геттеру
obj.propName = 'otherValue'; //обращаемся к сеттеру

```




## Спред-операторы

Еще называются операторами распространения. Используется для элементов, которые можно итерировать: объекты, массивы, строки. Перечисляет все ключи (если есть) и значения последовательности элемента.

Пример с объектами:
```javascript
		let obj = {a: 1, b: 2, c: 3};
		let obj2 = {d: 4};
		console.log({...obj}); //выводит {a: 1, b: 2, c: 3}
		console.log({...obj, ...obj2}); // выводит расширенный объект { a: 1, b: 2, c: 3, d: 4 } сами объекты при этом
		//не изменяются
		console.log({...obj, obj2}) // записывает obj2 как ключ obj
		console.log({...obj}, obj2) //выводит объекты obj и obj2 по-отдельности.
				//расширяем объект новой парой ключ-значение
		console.log({...obj, e: 5}); // выводит { a: 1, b: 2, c: 3, e: 5 }
				//сам объект прежний
		console.log(obj); // выводит { a: 1, b: 2, c: 3 }
				//можно клонировать объект
		let objClone = { ...obj };
		console.log(objClone); // выводит { a: 1, b: 2, c: 3 }
```

## Rest element

Например, есть объект:

```javascript
	const dict = {
		duck: 'quack',
		dog: 'wuff',
		mosue: 'squeak'
	};

	const {duck, ...otherAnimals} = dict;
	console.log(otherAnimals);

	//выведет {dog: 'wuff', mouse: 'squeak'}
```


Пример с массивами:
```javascript
		let arr = ['a', 'b', 'c'];
		console.log(...arr) //выводит a b c
		//расширяем массив
		console.log(...arr, 'd') //выводит a b c d
		//при этом сам массив прежний
		console.log(arr) //выводит [ "a", "b", "c" ]
```
## Деструктуризация объектов.

Пример:
```javascript
	const obj = {p: 42, q: true};
	const {p, q} = obj;
	//можно задать новые имена
	var {p: foo, q: bar} = obj;
	console.log(foo); // 42
	console.log(bar); // true
	//можно задать значения по умолчанию
	const obj = {p: 42, q: true};
	const {p, q, c = 'default'} = obj;
```

## Деструктуризация массивов.

Пример:
```javascript
	const fib = [1, 1, 2, 3, 5];
	const [a, b, c] = fib;
	console.log(a, b, c); //выведет 1 1 2
	//присваиваем определенные элементы
	const [,d,,e] = fib; //присваиваем константам только элементы с индексами 1 и 3
	console.log(d, e); //выведет 1 3
```
Пример 2:
```javascript
	const people = ['chris', 'sandra'];
	//присваиваем значение по умолчанию
	const [a, b, c = 'guest'];
	//также работает со спред-оператором
	const people = ['chris', 'sandra', 'bob'];
	const [a, ...others] = people;
	console.log(others); //выведет ['sandra', 'bob']
```

# Циклы

## for ...in

Цикл for...in проходит через перечисляемые свойства объекта. Он пройдёт по каждому отдельному элементу.

Пример:
```javascript
	const obj = {a:1, b:2, c:3};
	for (let key in obj) {
	  console.log("obj." + key + " = " + obj[key]);
	}
	// Выведет:
	// "obj.a = 1"
	// "obj.b = 2"
	// "obj.c = 3"
```
## for...of

Оператор for...of выполняет цикл обхода итерируемых объектов (включая Array, Map, Set, объект аргументов и подобных), вызывая на каждом шаге итерации операторы для каждого значения из различных свойств объекта.

Пример с массивом:
```javascript
	let iterable = [10, 20, 30];
	for (let value of iterable) {
	  value += 1;
	  console.log(value);
	}
	// 11
	// 21
	// 31
```
Пример со строкой:
```javascript
	let iterable = 'boo';
	for (let value of iterable) {
	  console.log(value);
	}
	// "b"
	// "o"
	// "o"
```

# Селекторы | навигация в DOM

Если у элемента есть атрибут id, то мы можем получить его вызовом `document.getElementById(id)`, где бы он ни находился.

Пример:
<div id="elem">
  <div id="elem-content">Element</div>
</div>

<script>
  // получить элемент
  let elem = document.getElementById('elem');

  // сделать его фон красным
  elem.style.background = 'red';
</script>


Также есть глобальная переменная с именем, указанным в id:

<div id="elem">
  <div id="elem-content">Элемент</div>
</div>

<script>
  // elem - ссылка на элемент с id="elem"
  elem.style.background = 'red';

  // внутри id="elem-content" есть дефис, так что такой id не может служить именем переменной
  // ...но мы можем обратиться к нему через квадратные скобки: window['elem-content']
</script>

Не рекомендуется напрямую обращаться к переменным по глобальному имени, указанному в атрибуте id. Оптимальнее использовать document.getElementById.


Самый универсальный метод поиска – это `elem.querySelectorAll(css)`, он возвращает все элементы внутри `elem`, удовлетворяющие данному CSS-селектору.

Следующий запрос получает все элементы <li>, которые являются последними потомками в <ul>:

<ul>
  <li>Этот</li>
  <li>тест</li>
</ul>
<ul>
  <li>полностью</li>
  <li>пройден</li>
</ul>
<script>
  let elements = document.querySelectorAll('ul > li:last-child');

  for (let elem of elements) {
    alert(elem.innerHTML); // "тест", "пройден"
  }
</script>


Псевдоклассы тоже работают

Псевдоклассы в CSS-селекторе, в частности :hover и :active, также поддерживаются. Например, document.querySelectorAll(':hover') вернёт коллекцию (в порядке вложенности: от внешнего к внутреннему) из текущих элементов под курсором мыши.


Метод `elem.querySelector(css)` возвращает первый элемент, соответствующий данному CSS-селектору.

Иначе говоря, результат такой же, как при вызове `elem.querySelectorAll(css)[0]`, но он сначала найдёт все элементы, а потом возьмёт первый, в то время как `elem.querySelector` найдёт только первый и остановится. Это быстрее, кроме того, его короче писать.


Метод `elem.matches(css)` ничего не ищет, а проверяет, удовлетворяет ли elem CSS-селектору, и возвращает `true` или `false`.

Этот метод удобен, когда мы перебираем элементы (например, в массиве или в чём-то подобном) и пытаемся выбрать те из них, которые нас интересуют.

Например:

<a href="http://example.com/file.zip">...</a>
<a href="http://ya.ru">...</a>

<script>
  // может быть любая коллекция вместо document.body.children
  for (let elem of document.body.children) {
    if (elem.matches('a[href$="zip"]')) {
      alert("Ссылка на архив: " + elem.href );
    }
  }
</script>

Метод `elem.closest(css)` ищет ближайшего предка, который соответствует CSS-селектору. Сам элемент также включается в поиск.

Другими словами, метод closest поднимается вверх от элемента и проверяет каждого из родителей. Если он соответствует селектору, поиск прекращается. Метод возвращает либо предка, либо null, если такой элемент не найден.

Например:

<h1>Содержание</h1>

<div class="contents">
  <ul class="book">
    <li class="chapter">Глава 1</li>
    <li class="chapter">Глава 2</li>
  </ul>
</div>

<script>
  let chapter = document.querySelector('.chapter'); // LI

  alert(chapter.closest('.book')); // UL
  alert(chapter.closest('.contents')); // DIV

  alert(chapter.closest('h1')); // null (потому что h1 - не предок)
</script>


`elem.getElementsByTagName(tag)` ищет элементы с данным тегом и возвращает их **коллекцию**. Передав " * " вместо тега, можно получить всех потомков.
пример:
```javascript
// получить все элементы div в документе
let divs = document.getElementsByTagName('div');
```
`elem.getElementsByClassName(className)` возвращает элементы, которые имеют данный CSS-класс.

`document.getElementsByName(name)` возвращает элементы с заданным атрибутом `name`. Очень редко используется.

Все методы `getElementsBy...` возвращают *живую* коллекцию. Такие коллекции всегда отражают текущее состояние документа и автоматически обновляются при его изменении.

Напротив, `querySelectorAll` возвращает *статическую* коллекцию. Это похоже на фиксированный массив элементов.

Иетод, который проверяет наличие отношений между предком и потомком:

`elemA.contains(elemB)` вернёт `true`, если `elemB` находится внутри `elemA` (`elemB` потомок `elemA`) или когда `elemA==elemB`.

## Работа с XML

Строку XML можно распрарсить подобно HTML-разметке. Ниже показан пример парсинга строки XML.

```javascript
		const xml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Reestr sourceSystemName="TestAS" callType="identification">
	<creditRequest id="100100">
		<participants>
			<participant id="100101" name="TESTOV">
				<document number="11010"/>
						<innerParameter>
								someValue
						</innerParameter>
			</participant>
		</participants>
		<requestParam type="testRequest"/>
	</creditRequest>
</Reestr>
`
		//инициализируем новый экземпляр класса DOMParser
		const parser = new DOMParser();
		//парсим строковый XML
		let parsedXML = parser.parseFromString(xml, 'text/xml'); //если успешно отработал вернет объект типа XMLDocument
		//обращаемся к свойствам тэга распарсенного XML
		let participantId = parsedXML.getElementsByTagName('participant')[0].attributes[0] //так как метод getElementsByTagName возвращает коллекцию типа HTMLCollection обращаемся к его свойству с индеком 0, так как искомый объект именно там
		//у тэга с наименованием participant читаем свойство attributes, которое возвращает сущность типа NamedNodeMap, также через индекс обращаемся к нужному атрибуту и на выходе получаем id="100101"

		//в свою очередь также можно обратиться к свойству nodeValue самого атрибута которое выведет его значение
		parsedXML.getElementsByTagName('participant')[0].attributes[0].nodeValue //выдаст 100101

		//для обращения ко внутренним данным, заключенным между тэгами можно использовать следующиe способы
		parsedXML.getElementsByTagName('innerParameter')[0].childNodes[0].data //вернет someValue
		parsedXML.getElementsByTagName('innerParameter')[0].childNodes[0].textContent //вернет someValue
		parsedXML.getElementsByTagName('innerParameter')[0].childNodes[0].nodeValue //вернет someValue
```

# Полезные методы

## Объекты

### Object.entries()

Метод возвращает массив собственных перечисляемых свойств указанного объекта в формате [key, value], в том же порядке, что и в цикле for...in (разница в том, что for-in также перечисляет свойства из цепочки прототипов)

Пример:
```javascript
		let dict = {
  				duck: 'quack',
   				dog: 'wuff',
    			mouse: 'squeak',
    			hamster: 'squeak'
		}
		let res = Object.entries(dict);
		console.log(res); // выведет двумерный массив [['duck', 'quack'], ['dog', 'wuff'], ['mouse', 'squeak'], ['hamster', 'squeak']]
```

## Массив

### Array.prototype.findIndex()
---

пример:
```javascript
	['a', 'b', 'c'].findIndex(element => element === 'b') //результат 1
	['a', 'b', 'c'].findIndex(element => element === 'd') //результат 2
```
Возвращает индекс элемента в массиве, если проходит проверку (если переданная аргументом функция в результате возвращает true). Если элемент не найден возвращает -1. Аргументом имеем функцию, производящую проверку. Удобно использовать для поиска индекса элемента по его значению.

---
### Array.prototype.find()
---

Возвращает значение первого найденного в массиве элемента, который проходит проверку, согласно переданной функции как аргумент. Если элементов, удовлетворяющих условиям проверки нет, возвращает `undefined`.

пример:
```javascript
	[1, 2, 3].find(el => el > 2); //результат 3
```

### Array.prototype.indexOf()
---

Возвращает первый индекс, по которому данный элемент может быть найден в массиве или -1, если такого индекса нет.
Очень удобен для определения наличия элемента по значению. Второй аргумент опционален и определяет индекс, с которого начинать поиск. Если индекс является отрицательным числом, он трактуется как смещение с конца массива.

пример:
```javascript
	[2, 3, 7, 8, 9, 5].indexOf(7); //вернет 2
	[2, 3, 7, 8, 9, 5].indexOf(11); //вернет -1, так как элемента со значеним 11 в массиве нет
```

### Array.prototype.push()
---

Метод `push()` добавляет один или более элементов в конец массива и возвращает новую длину массива.

пример:
```javascript
	let sports = ['футбол', 'бейсбол'];
	let total = sports.push('американский футбол', 'плавание');
	console.log(sports); // ['футбол', 'бейсбол', 'американский футбол', 'плавание']
```
### Array.prototype.pop()
---
Метод pop() удаляет последний элемент из массива и возвращает его значение (или undefined, если массив пуст).


### Array.prototype.slice()** (не путать со `splice()`)
---

Метод `slice()` возвращает новый массив, содержащий копию части исходного массива.

Аргументы:
* первым аргументом является индекс, с которого начинать извлечение (по умолчанию 0), если отрицательный, то указывает на смещение от конца массива.
* вторым аргументом является индекс до которого заканчивать извлечение (исключительно).
Вызов `slice(0, 4)` извлечёт элементы со первого по четвёртый (элементы по индексам 0, 1, 2 и 3).
По умолчанию второй аргумент равен длине массива.



### Array.prototype.splice()** (не путать со `slice()`)
---

Метод splice() изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые. Возвращает массив с удаленными элементами.

Аргументы:
* Первый аргумент указывает на индекс с которого начинать изменять массив.
* Второй аргумент - число, определяющее количество удаляемых элементов. Если 0, то не удаляются.
* Третий аргумент - Добавляемые/удаляемые элементы.

пример:
```javascript
		let myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
		let removed = myFish.splice(2, 0, 'drum');
		// myFish равен ["angel", "clown", "drum", "mandarin", "sturgeon"]
		// removed равен [], ничего не удалено
```

### Array.prototype.forEach()
---
Метод forEach() выполняет указанную функцию один раз для каждого элемента в массиве.

Пример:
```javascript
	const arraySparse = [1,3,,7]
	let numCallbackRuns = 0;
	arraySparse.forEach((element) => {
	  console.log(element);
	  numCallbackRuns++;
	})
	// 1
	// 3
	// 7
	// numCallbackRuns: 3
	// пропущенное значение между 3 и 7 не вызывало функцию callback
```
Сравнение с циклом for:
```javascript
	const items = ['item1', 'item2', 'item3'];
	const copy = [];
	// до
	for (let i = 0; i < items.length; i++) {
	  copy.push(items[i]);
	}
	// после
	items.forEach(function(item){
	  copy.push(item);
	})
```
**Важно!** forEach() не изменяет исходного массива примитивов, если опустить второй аргумент в вызываемой функции!

Пример:
```javascript
	let array = [1, 2, 3];
	array.forEach(el => {
	el+=1;
	console.log(el);
	})
	//вывод:
	//2
	//3
	//4
	//но если вывести после этого сам массив, он остался неизменным:
	console.log(array);
	//[ 1, 2, 3 ]
```
Но, если:
```javascript
	let array = [1, 2, 3];
	array.forEach((el, idx) => {
	array[idx] += 1;
	})
	console.log(array);
	//вывод: [ 2, 3, 4 ]
	//исходный массив изменился!
```
Дело в том что при каждой итерации первый аргумент el по значению равен array[idx], но не является одним и тем же объектом! При изменении el изменяется только это переменная а не элементы массива.

Также можно отметить, если мы имеем массив объектов, изменение по первому аргументу возможно.

```javascript
	var arr = [{ num : "one" }, { num : "two"}, { num : "three"}];
	arr.forEach(function(part, index) {
	  // part и arr[index] указывают на один и тот же объект
	  // таким образом изменяя объект, на который указывает part, изменяет объект на который указывает arr[index]
	  part.num = "four";
	});

	alert(arr[0].num);
	alert(arr[1].num);
	alert(arr[2].num);
```

### Array.prototype.filter()
---

Метод filter() создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.

Пример:
```javascript
	const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];
	const result = words.filter(word => word.length > 6);
	console.log(result);
	// expected output: Array ["exuberant", "destruction", "present"]
```
### Array.prototype.map()
---

Метод map() создаёт **новый** массив с результатом вызова указанной функции для каждого элемента массива.

Пример:
```javascript
	let numbers = [1, 4, 9];
	let doubles = numbers.map((num) => {
	  return num * 2;
	});
	// теперь doubles равен [2, 8, 18], а numbers всё ещё равен [1, 4, 9]
```

### Array.prototype.reduce()
---

Метод `reduce()` применяет функцию reducer к каждому элементу массива (слева-направо), возвращая одно результирующее значение.

Пример считает сумму элементов массива (`idx` и `array` можно опустить):

```javascript
[0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, idx, array) {
  return previousValue + currentValue;
});
```
1. 0 + 0 = 0 [idx: 0]
2. 0 + 1 = 1 [idx: 1]
3. 1 + 2 = 3 [idx: 2]
4. 3 + 3 = 6 [idx: 3]
5. 6 + 4 = 10 [idx: 4]
результат: 10

Можно задать начальное значение, например:
```javascript
[0, 1, 2, 3, 4].reduce(function(accumulator, currentValue, idx, array) {
  return accumulator + currentValue;
}, 10);
```
1. 10 + 0 = 10 [idx: 0]
2. 10 + 1 = 11 [idx: 1]
3. 11 + 2 = 13 [idx: 2]
4. 13 + 3 = 16 [idx: 3]
5. 16 + 4 = 20 [idx: 4]
результат: 20


На первой итерации переменная `previousValue` равна 0 (так как не передан в reduce второй параметр начального значения)

При последующих итерациях `previousValue` сохраняет значение полученное в результате предыдущей итерации.

Значение, возвращённое методом `reduce()` будет равным последнему результату выполнения функции обратного вызова (10).

Пример с логированием без начального значения

```javascript
[0, 1, 2, 3, 4].reduce(function(accumulator, currentValue, idx) {
    console.log(`Index: ${idx},
    accumulator: ${accumulator},
    currentValue: ${currentValue},
    will return ${accumulator + currentValue}`)
  return accumulator + currentValue;
});

//консоль

// Index: 1,
//     accumulator: 0,
//     currentValue: 1,
//     will return 1
// Index: 2,
//     accumulator: 1,
//     currentValue: 2,
//     will return 3
// Index: 3,
//     accumulator: 3,
//     currentValue: 3,
//     will return 6
// Index: 4,
//     accumulator: 6,
//     currentValue: 4,
//     will return 10

```


### Array.prototype.reduceRight()
---

Применяет функцию, переданную в качестве аргумента к аккумулятору (результату вызова предыдущей итерации) и каждому значению массива справа налево, приводя в итоге к одному значению.

Функция, которая выступает в качестве аргумента в свою очередь принимает 4 аргумента:

    previousValue
        Значение, возвращённое предыдущим выполнением функции, либо значение initialValue, если оно предоставлено.
    currentValue
        Текущий обрабатываемый элемент массива.
    index
        Индекс текущего обрабатываемого элемента массива.
    array
        Массив, для которого была вызвана функция reduceRight.
	initialValue
	    Необязательный параметр. Объект, используемый в качестве первого аргумента при первом вызове функции.

Пример:
```javascript
[0, 1, 2, 3, 4].reduceRight((previousValue, currentValue) => {
  return previousValue + currentValue;
});
//вернет 10
```

Если выполнить с логированием

```javascript
[0, 1, 2, 3, 4].reduceRight((previousValue, currentValue, i) => {
    console.log(`Index: ${i},
previousValue: ${previousValue},
currentValue: ${currentValue},
will return ${previousValue + currentValue}`)
  return previousValue + currentValue;
});

//вывод консоли:

// Index: 3,
// previousValue: 4,
// currentValue: 3,
// will return 7

// Index: 2,
// previousValue: 7,
// currentValue: 2,
// will return 9

// Index: 1,
// previousValue: 9,
// currentValue: 1,
// will return 10

// Index: 0,
// previousValue: 10,
// currentValue: 0,
// will return 10


```


## Дата. Объект Date

Вывод текущей даты и времени в виде строки, в формате ISO: YYYY-MM-DDTHH:mm:ss.sssZ
```javascript
	new Date().toISOString().replace('T', ' ').replace('Z', ' ');
	//пример вывода 2020-04-10 11:25:54.706 (по Гринвичу)

	new Date().toLocaleString('ru');
	//выводит местное вермя, пример выше: 10.04.2020, 14:27:58
```


`Date.parse()`

Метод Date.parse() разбирает строковое представление даты и возвращает количество миллисекунд, прошедших с 1 января 1970 года 00:00:00 по UTC.

Прямой вызов:
```javascript
Date.parse(dateString);
```

Пример конвертации строковой даты в `timestamp`:
```javascript

	let dateTS = Date.parse('2020-10-22T11:00:00.000Z')/1000;
	new Date(dateTS*1000).toISOString(); //выдаст дату в строковом формате ISO

```

Пример функции реализованной на прототипе Date добавляющей часы к экземплярам Date:
```javascript
	Date.prototype.addHours = function(h) {
	    this.setTime(this.getTime() + (h*60*60*1000));
	    return this;
	    }

```
Пример функции, выполняющей уменьшение времени на заданное значение минут
```javascript

    timeDecrementMinutes = (dateTime, minutes) => {

    	//приводим строку к экземпляру Date
        dateTime = new Date(dateTime);
        //используем встроенные методы класса Date для уменьшения минут
        dateTime = dateTime.setMinutes(dateTime.getMinutes() - minutes);
        //возвращаем ответ в виде строки формата ISO
        return new Date(dateTime).toISOString();
    }

    //пример вызова функции timeDecrementMinutes
	let decrementedTime = timeDecrementMinutes('2020-10-22T11:00:00.000Z', 5);
```

## JSON

Объект JSON содержит методы для разбора объектной нотации JavaScript (JavaScript Object Notation — сокращённо JSON) и преобразования значений в JSON. Его нельзя вызвать как функцию или сконструировать как объект, и кроме своих двух методов он не содержит никакой интересной функциональности.

### stringify

Метод `JSON.stringify()` преобразует значение JavaScript в строку JSON, возможно с заменой значений, если указана функция замены, или с включением только определённых свойств, если указан массив замены.

Параметры

`value`
    Значение, преобразуемое в строку JSON.
`replacer` Необязательный
    Если является функцией, преобразует значения и свойства по ходу их преобразования в строку; если является массивом, определяет набор свойств, включаемых в объект в окончательной строке.
    Подробное описание функции `replacer` даётся в статье Использование родного объекта JSON (en-US) руководства по JavaScript.
`space` Необязательный
    Делает результат красиво отформатированным (расставляя пробелы).

Пример форматирования с пробелами:

```javascript
JSON.stringify({a: 1, b: 'test', c: {ac: 'test string'}}, null, 2);

// результат:

{
  "a": 1,
  "b": "test",
  "c": {
    "ac": "test string"
  }
}
```

# Функции

## Функции-стрелки или Arrow-функции

Ключевыми понятиями, связанными с функциями также являются лексическое окружение, контекст выполнения, стек вызовов.

*Лексическое окружение* это специальный объект, создаваемый при вызове функции, в котором хранится информация о ее блоке кода: например переменные, другие функции, а также ссылка на внешнее лексическое окружение.
При объявлении функции также создается специальное свойство `[[Environment]]` которое хранит данные о том месте, где функция создана.

Лексическое окружение также связано с контекстом выполнения функции.

*Контекст выполнения* - специальная внутренняя структура данных, которая содержит информацию о вызове функции. Она включает в себя конкретное место в коде, на котором находится интерпретатор, локальные переменные функции, значение `this` (мы не используем его в данном примере) и прочую служебную информацию.

Контекст выполнения можно представить как стековый кадр. Контекст выполнения управляется в стеке вызовов.

С каждым новым запуском функции запускатеся новый контекст выполнения как и лексическое окружение.

Если функция при выполнении вызывает саму себя это называется *рекурсией*.

Каждый раз как только в момент выполнения функции внутри вызывается другая (включая рекурсию) текущий контекст выполнения запоминается в стеке контекстов выполнения (стек вызовов) и приостанавливается, создается новый контекст для вложенного вызова, когда выполнение вложенного вызова заканчивается восстанавливается контекст предыдущего и продолжается выполнение.





Пример синтаксиса объявления (сигнатуры) функции-стрелки, не принимающей аргументов:
```javascript
	const exampleFunction = () => {...};
```

Пример объявления асинхронной функции:

```javascript
	const asyncFunction = async () => {...};
```
или более старый синтаксис:
```javascript
async function asyncFunction() {
	...
};
```


В стрелочных функциях ключевое слово `return` необязательно в случае, когда тело функции имеет одну строку:


```javascript
	const calcFunc = (x, y) => x + y;
```

```javascript
	const sq = (x) => x*x;
```
Если же строк более одной, обязательны фигурные скобки {}:

```javascript
	const sq = (x) => {
		console.log(x);
		return x*x;
	};
```

Также если строк более одной и функция должна возвращать результат, обязательным становится ключевое слово `return`.

Важная особенность arrow-функций также в том, что они сохраняют значение ключевого слова `this`.

Пример для объяснения момента с ключевым словом `this`:
```javascript
	const greeter = {
		greet: function (name) {
			console.log('Hello', name);
		},

		greetAll: function (names) {
			names.forEach(function(name) {
				this.greet(name);
			});
		}
	};
	greeter.greetAll(['Bob', 'Mark', 'Pete']);
```

Код выше выведет ошибку: `this.greet is not a function...`

Когда мы вызваем `greetAll` внутри этой функции значение `this` все еще объект `greeter`, но внутри функции, которую мы передаем в `forEach` значение `this` теряется, поэтому функция уже не находится. Но если мы заменим объявление функции в forEach на функцию-стрелку:

```javascript
		greetAll: function (names) {
			names.forEach((name) => {
				this.greet(name);
			});
```
Ошибки возникать не будет, потому что функция-стрелка сохраняет значение лексического `this`, то есть внутри функции-стрелки `this` будет тем же, как внутри той функции где мы ее объявляем, т.е. внутри функции `greetAll`.

У функций-стрелок нет свойства `Prototype` в отличие от объявленных ключевым словом `function`

`Prototype` - это механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга.

## Параметры по умолчанию (Deafult Parameters) в функциях

Если в аргументах фунции нужно значать значения по умолчанию, если не переданы, удобно использовать синтаксис:

```javascript
	const fetchOrders = (count = 10, start = 0) => {
		console.log(count, start);
	}
	//при вызове
	fetchOrders();
	//будут применены значения параметров по умолчанию
```

Значения по умолчанию не обязательно присваивать каждому аргументу. Значние `null` является обычным значением и если оно передано как значение аргумента функции, то значение по умолчанию не будет назначено при вызове функции. Только `undefined` заменяется на значение по умолчанию.

Значение по умоланию также может быть объектом, или массивом.

Пример значений по умолчнию в свойствах аргументе-объекта функции с помощью деструктуризации объекта.

```javascript
	const connect = ({
		host = 'localhost',
		port = 12345,
		user = 'guest'
	}) => {
		console.log(user);
	}
```
Для предотвращения ошибок, когда в вызое функции объект не передан вообще, можно использовать такой синтаксис:
```javascript
	const connect = ({
		host = 'localhost',
		port = 12345,
		user = 'guest'
	} = {}) => {
		console.log(user);
	}
```




## Rest parameter

Используется, когда нет ограничений на список аргументов функции.

Rest parameter - это особый параметр, который группирует в массив все аргументы, которые не были присвоены заданным параметрам.

Пример:

```javascript
	const max = (...numbers) => {
		console.log(numbers);
	}
	//пример вызова
	max(1, 3, 4);
```

Если при вызове функции, которая объявлена с Rest parameter не будет передано ни одного аргумента, то на вход функции поступит пустой массив `[]`.

Также перед Rest parameter можно задавать и другие параметры:

```javascript
	const max = (a, b, ...numbers) => {
		console.log(numbers);
	}
	max(1, 2, 3);
	//a присвоится значение 1
	//b присвоится значение 2
	//значение 1 перейдет в массив numbers как единственное значение
```
Rest parameter обязательно должен быть последним при объявлении функции. Также нельзя иметь более одного Rest parameter.


Если в функции вызывается вложенная функция, которая возвращает результат, сам этот результат также необходимо вернуть, если функция должна возвращать результат.

Например:
```javascript
	const arrayDouble = (array) => {
		return array.map(element => {
			return element * 2;
			})
	}
```
Функция arrayDouble возвращает новый видоизмененный массив. Так как сама функция arrayDouble внутри себя использует метод глобального объекта Array, который возвращает новый видоизмененный массив, этот результат работы метода `map()` также надо вернуть из функции arrayDouble

Главное отличие метода `map()` от `forEach()` в том, что `map()` возвращает новый массив, а `forEach()` выполняет действия на текущем массиве и возвращает `undefined`.





## Промисы и асинхронные функции. Контрукция async / await. Promise


Объект `Promise` (промис) используется для отложенных и асинхронных вычислений.

Пример объявления промиса:
```javascript
	const promise1 = new Promise((resolve, reject) => {
	  setTimeout(() => {
	    resolve('foo');
	  }, 300);
	});
	//вызов и получение результата
	promise1.then(value => {
		console.log(value);
		// ожидаем вывода в логах консоли: "foo"
		console.log(promise1);
		// ожидаем вывода в логах консоли: [object Promise]
	});
```
Функция, которая передается аргументом при объявлении нового экземпляра промиса называется `executor` и в свою очередь принимает 2 аргумента: `resolve` и `reject`. Функция `executor`  получает оба аргумента и выполняется сразу, еще до того как конструктор вернет созданный объект.
Первый аргумент (`resolve`) вызывает успешное исполнение промиса, второй (`reject`) отклоняет его.
Обычно функция `executor` описывает выполнение какой-то асинхронной работы, по завершении которой необходимо вызвать функцию `resolve` или `reject`. Возвращаемое значение функции `executor`игнорируется.

Обратите внимание на то, что вы можете передать что угодно (или ничего) при вызове `Promise.reject()`, однако, рекомендуется всегда передавать этому методу объект `Error`.

Интерфейс `Promise` (промис) представляет собой обертку для значения, неизвестного на момент создания промиса. Он позволяет обрабатывать результаты асинхронных операций так, как если бы они были синхронными: вместо конечного результата асинхронного метода возвращается обещание (промис) получить результат в некоторый момент в будущем.

`Promise` может находиться в трёх состояниях:

* ожидание (pending): начальное состояние, не исполнен и не отклонен.
* исполнено (fulfilled): операция завершена успешно.
* отклонено (rejected): операция завершена с ошибкой.

Так как методы `Promise.prototype.then()` и `Promise.prototype.catch()` сами возвращают промис, их можно вызывать цепочкой, создавая соединения.

Метод `Promise.all(iterable)` ожидает исполнения всех промисов или отклонения любого из них. Возвращает промис, который исполнится после исполнения всех промисов в iterable. В случае, если любой из промисов будет отклонен, Promise.all будет также отклонен.

В JavaScript ES8 появилась конструкция async / await, которая упрощает работу с промисами. Сейчас мы кратко рассмотрим возможности, которые предлагает async / await и поговорим о том, как использовать эти возможности для написания асинхронного кода.

Асинхронные функции объявляют, пользуясь ключевым словом `async`. Такая функция возвращает объект `AsyncFunction`. Этот объект представляет собой асинхронную функцию, которая выполняет код, находящийся внутри неё.

Когда асинхронная функция вызывается, она возвращает объект `Promise`. Если такая функция возвращает значение, которое не является объектом `Promise`, этот объект будет автоматически создан и разрешён с использованием значения, возвращённого функцией. Если функция, объявленная с ключевым словом async, выдаст исключение, промис будет отклонён с этим исключением.

Функция, объявленная с ключевым словом async, может содержать выражение с ключевым словом `await`, которое приостанавливает выполнение функции и ожидает разрешения промиса, фиругирующего в данном выражении. После этого выполнение async-функции продолжается, и, например, осуществляется возврат полученного после разрешения промиса значения.

Объекты Promise в JavaScript можно рассматривать как эквиваленты Future из Java или задач из C#.

Цель async / await заключается в том, чтобы упростить использование промисов.
Взглянем на следующий пример:

```javascript
// Это - самая обыкновенная JS-функция
	const getNumber1 = () => {
	    return Promise.resolve('374');
	};
	// Эта функция делает то же самое, что и getNumber1
	const getNumber2 = async () => {
	    return 374;
	};
```
Асинхронные функции, которые выдают исключения, аналогичны функциям, которые возвращают отклонённые промисы:
```javascript
function f1() {
    return Promise.reject('Some error');
};
async function f2() {
    throw 'Some error';
};
```

Ключевое слово `await` можно использовать только в функциях, объявленных с ключевым словом `async`. Оно позволяет организовать ожидание разрешения промиса. Если мы используем промисы за пределами async-функций, нам всё ещё нужно использовать коллбэки блока `then`:
```javascript
const loadData = async () => {
    // `rp`- это функция request-promise.
    const promise1 = rp('https://api.example.com/endpoint1');
    const promise2 = rp('https://api.example.com/endpoint2');

    // В данный момент выполняются оба запроса
    // и нам нужно подождать их завершения.
    const response1 = await promise1;
    const response2 = await promise2;
    return response1 + ' ' + response2;
	};
	// Так как мы больше не в функции, объявленной с ключевым словом `async`
	// нам нужно использовать `then` с возвращённым объектом Promise
	loadData().then(() => console.log('Done'));
```


Использование конструкции `async / await` позволяет вам писать гораздо меньше кода. Каждый раз, используя `async / await`, вы избавляетесь от нескольких ненужных шагов. Среди них — использование блока `.then()`, создание анонимной функции для обработки ответа, задание в этой функции-коллбэке имени для переменной, содержащей результаты ответа, и так далее.

Вот фрагмент кода, в котором используются промисы:

```javascript
	// `rp`- это функция request-promise.
	rp('https://api.example.com/endpoint1').then((data) => {
	 // …
	});
```
Вот то же самое, написанное с использованием `async / await`:
```javascript
	// `rp`- это функция request-promise.
	const response = await rp('https://api.example.com/endpoint1');
```
**Обработка ошибок**

Конструкция `async / await` позволяет обрабатывать синхронные и асинхронные ошибки с использованием одних и тех же механизмов. А именно, речь идёт о широко известном выражении `try / catch`.

Взглянем на то, как обработка ошибок выполняется при использовании промисов. В частности, здесь нам приходится использовать блок `.catch()` для обработки асинхронных ошибок, и блок `try / catch` для обработки синхронных ошибок:

```javascript
const loadData = () => {
    try { // Перехват синхронных ошибок.
        getJSON().then(function(response) {
            var parsed = JSON.parse(response);
            console.log(parsed);
        }).catch(function(e) { // Перехват асинхронных ошибок
            console.log(e);
        });
    } catch(e) {
        console.log(e);
    }
}
```
Вот как обрабатывать ошибки при использовании async / await:
```javascript
loadData = async () => {
    try {
        var data = JSON.parse(await getJSON());
        console.log(data);
    } catch(e) {
        console.log(e);
    }
}
```
Некоторые практические примеры
```javascript
//в данном примере показана цепь промисов
const promiseOne = new Promise((resolve, reject) => {
	setTimeout(() => {
		console.log(`promise resolved`);
		resolve(true);
	}, 2000);

})

//из данного промиса можно вывести цепь


promiseOne
	.then(flag => {
		if (flag) {
			//выполняется блок кода
			//не обязательно явно указвать что возвращается промис
			return true;
		} else return false;
	})
	.then(flag2 => {
		//продолжаем работу в цепочке
	})
	.catch(error => console.error(error)); //настоятельно рекомендуется добавлять catch в конце цепи для отлова исключений
	.finally(() => {
		//данный блок кода выполнится в любом случае
		//использование данного метода опционально
	})

```

```javascript
//вызов массива промисов

const sleep = (ms) => {
	return new Promise(resolve => {
		setTimeout(() => resolve(), ms);
	})
}

//при необходимости выполнения нескольких промисов можно использовать метод all

//на вход принимает массив промисов
Promise.all([sleep(1000), sleep(3000), sleep(8000)])
	.then(() => {
		//данный блок кода будет выполнен, когда ВСЕ переданные в масив промис успешно разрешатся (resolve)
		console.log(`All promises successfully resolved`);
	})
	.catch((e) => console.log(e))


//метод race

Promise.race([sleep(1000), sleep(3000), sleep(8000)])
  .then(() => {
  	//данный блок кода исполнится после того как первый из промисов разрешится
  })
  .catch((e) => console.log(e));



```




## IIFE Immediately Invoked Function Expression | самозапускающаяся функция

IIFE - это функции, которые запускаются на выполнение сразу после объявления.

IIFE выглядит так:
```javascript
(function() {

  let message = "Hello";

  alert(message); // Hello

})();
```
Или в виде функции-стрелки:
```javascript
(() => {

  let message = "Hello";

  alert(message); // Hello

})();
```
Также для асинхронных функций:
```javascript
(async () => {
    // code goes here
})();
```

Пример с параметрами:
```javascript
(async (title, text) => {
    try {
        let result = await db.insertPost(title, text);
        res.send(result);
    } catch (e) {
        res.send(e);
    }
})(title, text);
```

## Элементы функционального программирования

### Чистые функции

Чистые функции — это первая фундаментальная концепция, которую нужно изучить для того, чтобы понять сущность функционального программирования.

Чистая функция должна отвечать следующим требованиям:
1. Она всегда возвращает, при передаче ей одних и тех же аргументов, один и тот же результат (такие функции также называют детерминированными).
2. Такая функция не обладает побочными эффектами.

Пример чистой функции
```javascript
const PI = 3.14;

//чистая функция не зависит от значения внешних по отношению к данной функции переменных
function calculateAreaClean(radius, pi) {
  return radius * radius * pi;
}

calculateArea(10, PI); // возвращает 314

//для сравнения пример не чистой функции, зависит от внешней константы PI
const PI = 3.14;

function calculateArea(radius) {
  return radius * radius * PI;
}

calculateArea(10); // возвращает 314

```

#### Побочные эффекты

Примером побочного эффекта, который может проявиться при вызове функции, является модификация глобальных переменных или аргументов, передаваемых функциям по ссылке.

```javascript
//данная функция не является чистой, так как изменяет значение внешней переменной
let counter = 1;
let counterCleanExample = 1;

function increaseCounter(value) {
  counter = value + 1;
}

increaseCounter(counter);
console.log(counter); // 2 Глобальная переменная меняется, подобное в функциональном программировании не приветствуется.


//чистая функция, не изменяет значение внешней по отношению к данной функции переменной
function increaseCounterClean(value) {
  return value + 1;
}

increaseCounter(counterCleanExample); // 2
console.log(counterCleanExample); // 1

```
Если следовать двум вышеописанным правилам написания чистых функций, это приведёт к тому, что в программах, созданных с использованием таких функций, будет легче ориентироваться. Окажется, что каждая функция будет изолирована и не будет оказывать воздействия на внешние по отношению к ней части программы.


Среди сильных сторон чистых функций можно отметить тот факт, что код, написанный с их использованием, легче тестировать. В частности, не нужно создавать неких объектов-заглушек. Это позволяет выполнять модульное тестирование чистых функций в различных контекстах:

	* Если функции передаётся параметр A — ожидается возврат значения B.
	* Если функции передаётся параметр C — ожидается возврат значения D.

В качестве простого примера этой идеи можно привести функцию, которая принимает массив чисел, и при этом ожидается, что она увеличит на единицу каждое число этого массива, вернув **новый** массив с результатами:

```javascript
let list = [1, 2, 3, 4, 5];

function incrementNumbersClean(list) {
  return list.map(number => number + 1);
}
```

#### Иммутабельность (неизменчивость)

Иммутабельность некоей сущности можно описать как то, что с течением времени она не меняется, или как невозможность изменений этой сущности.

Если иммутабельный объект пытаются изменить — сделать этого не удастся. Вместо этого нужно будет создать новый объект, содержащий новые значения.

Например, в JavaScript часто используется цикл for. В ходе его работы, как показано ниже, применяются мутабельные переменные:

```javascript
var values = [1, 2, 3, 4, 5];
var sumOfValues = 0;

for (var i = 0; i < values.length; i++) {
  sumOfValues += values[i];
}

sumOfValues // 15
```
На каждой итерации цикла меняется значение переменной i и значение глобальной переменной (её можно считать состоянием программы) sumOfValues. Как в подобной ситуации поддерживать неизменность сущностей? Ответ лежит в использовании рекурсии.
```javascript
let list = [1, 2, 3, 4, 5];
let accumulator = 0;

function sum(list, accumulator) {

  if (list.length == 0) {
  	//терминальная (базовая) ветвь (условие прекращения рекурсии)
    return accumulator;
  }
//рекурсивная ветвь (шаг)
  return sum(list.slice(1), accumulator + list[0]);
}

sum(list, accumulator); // 15
list; // [1, 2, 3, 4, 5]
accumulator; // 0
```
Тут имеется функция `sum()`, которая принимает массив чисел. Эта функция вызывает сама себя до тех пор, пока массив не опустеет (это базовый случай нашего рекурсивного алгоритма). На каждой такой «итерации» мы добавляем значение одного из элементов массива к параметру функции `accumulator`, не затрагивая при этом глобальной переменной `accumulator`. При этом глобальные переменные `list` и `accumulator` остаются неизменными, до и после вызова функции в них хранятся одни и те же значения.

Правильно написанная рекурсивная функция должна гарантировать, что через конечное число рекурсивных вызовов будет достигнуто выполнение условия прекращения рекурсии, в результате чего цепочка последовательных рекурсивных вызовов прервётся и выполнится возврат.


### Функции, возвращающие другие функции | Каррирование

Если функция на вход принимает n (n > 1) аргументов, ее можно преобразовать в функцию возвращающую n - 1 функций от каждого аргумента, этот метод называется **каррирование**.
В языке JavaScript нередко можно встретить конструкцию таких функций, возвращающих другие функции. Например, нередко каррирование используется в библиотеке Redux. Для того, чтобы правильно оперировать данной возможностью необходимо ясно понимать как работает данный подход.
Более строгое определение каррирования: функция двух переменных x и y `f(x,y)=x+y` может быть рассмотрена как функция одной переменной x, возвращающая функцию одной переменной y.

### Простой пример вложенных функций для вычисления суммы аргументов:


```javascript
const nestedFunc = (x) => (y) => (z) => {

    console.log( x + y + z );
    return x + y + z;
}
```
Здесь первая функция `nestedFunc` с аргументом `x` возвращает следующую функцию у которой аргумент `y`, которая в свою очередь возвращает функцию с аргументом `z`

Если мы ее вызовем таким образом:

```javascript

//в результате вернется просто следующая функция

nestedFunc(1,1,1) // вернет function nestedFunc(y)

```

Результатом будет анонимная функция с аргументом `y`.

Чтобы корректно вызвать и исполнить такую функцию аргументы должны разделяться круглыми скобками, где их количество равно количеству вызываемых функций:

```javascript

//вызов будет последовательным
nestedFunc(1)(1)(1) // вернет результат 3

//еще пример работы с вложенными функциями:
let func1 = nestedFunc(1) //вернет func1
let func2 = func1(1) //вернет func2
let func3 = func2(1) // вернет результат 3

//или

let funcSome = nestedFunc(1)(1) // вернет результат 3

```

Нередко техника вложения промежуточных функций применяется для сокращения количества аргументов отдельной функции и повышения читаемости кода, ее еще называют "частично примененные функции" (partially applied functions). Такие функции принимают часть аргументов и возвращают новые функции с меньшим количеством аргументов.


### Композиция функций

Представьте такой пример. Есть 3 функции которые должны работать с результатами предыдущей функции.
```javascript
const f1 =(x, y) => x + y;

const f2 = (z) => z * 10;

const f3 = (q) => console.log(`Result ${q}`);
```
Мы могли бы это реализовать следующим образом:

```javascript

f3(f2(f1(5,7))) //Result 120

//сначала исполняется f1, ее значение в качестве аргумента передается f2 и результат вычисления f2 передается
//в качестве аргумента в f3 которая исполняется последней в данной цепочке

```
Запись выше не очень удобна с точки зрения читабельности и сопровождения кода.

Вместо этого можно составить композицию функций, для этого напишем отдельную функцию.


```javascript

//в качестве аргумента принимает набор функций
const compose = (...funcs) => {

//возвращает другую функцию, аргумент которой будет использован для работы
//переданных в наборе функций
     return (x, y = 0) => {
        let accumulator;
        //проходимся по массиву функций
        return funcs.forEach((func, i) => {
                if (i == funcs.length - 1) {
                	//если мы в конце массива то возвращаем результат вызова последней функции в массиве
                return accumulator = func(accumulator);
                }
                if (i > 0) {
                	//если итерация не первая, то записываем результат вызова
                	//следующей функции в промежуточную перменную
                    accumulator = func(accumulator);

                } else {
                	//в самом начале вызываем функцию с начальными аргументами
                    accumulator = func(x, y);
                }


            })
    }

}

//теперь можем вызвать функции описанные выше, сконпоновав их таким образом
compose(f1, f2, f3)(5, 7); //Result 120


```

Еще один способ композиции функций с помощью метода `reduceRight`


```javascript

const f1 = (x) => (y) => x + y;

const f2 = (z) => z * 10;

const f3 = (q) => console.log(`Result ${q}`);




const compose2 = (...funcs) => (arg) => {


                return funcs.reduceRight((prevResult, currentFunc) => {

                       return currentFunc(prevResult);

            	}, arg)

         }

compose2(f3, f2, f1(5))(7) //Result 120


```

### Пример с логированием

```javascript
const nestedFunc3 = (x) => {

    console.log(`First function called`+'\n');
        return (y) => {
            console.log(`Second function called`+'\n');
            return (z) => {
                console.log(`Third function called`+'\n');
                return x + y + z;
            }

        }
    }

    nestedFunc3(1)(1)(1);

    // выведет:
// First function called
// вернул вторую функцию и сразу вызвал
// Second function called
// вернул третью функцию и сразу вызвал
// Third function called
// третья функция выполнила сложение и вернула результат

```
Обратите внимание, что доступ к аргументам вышестоящих функций нижележащие функции получают из своего внешнего лексического окружения. Это наглядный пример замыканий в JavaScript.

### Пример с функцией в качестве аргумента

Допсутим, есть 2 функции, выполняющих различные функции. Чтобы не вызывать последовательно каждый раз вручную каждую из них, если одна из функций должна выполнить операцию, основывающаюся на результата выполнения предыдущих функций, то можно выполнить композицию функций.


```javascript

//функция делит аргумент на 2

const divisionByTwo = (num) => {

console.log(`divisionByTwo function called`+'\n');
return num / 2;

}

//вычисляет сумму аргументов
//в аргумент next будет передаваться необходимая для обработки функция
const nestedDeeperFunc = (x) => {

    console.log(`First function called`+'\n');
    return (next) => {
        console.log(`Second function called`+'\n');
        return (y) => {
            console.log(`Third function called`+'\n');
            return next(x + y);
        }

    }
}

//если мы вызовем функцию nestedDeeperFunc таким образом

//Направление выполнения слева направо =>

nestedDeeperFunc(2)(divisionByTwo)(2);

//Результат будет равен 2

// First function called
//
// Second function called
//
// Third function called
//
// divisionByTwo function called

```

### Пример с функцией суммы
```javascript
const sum_2 = (n) => {
  let s = n;
  const nextSum = (x) => {
    s += x;
    return nextSum;
  };
  nextSum.toString = () => s.toString(); //чтобы возвращалось именно строковое значение
  return nextSum;
};

console.log(+sum_2(8)(2)(8)); //пример с унарным оператором + (который выполняет приведение типа к number)
console.log(sum_2(1)(2)(7)(1)); //в Firefox отображается функция, а в Chrome сумма
console.log(sum_2(1)(2)(7)(1).toString()); //просто для наглядности
```
Пример выше показывает функцию `sum_2`, которая возвращает n функций в зависимости от количества вызовов с аргументами, в самом последнем вызове всегда будет возвращаться функция. Чтобы получить свойство (сумму), мы переопределяем метод глобального объекта `Object` (так как любая функция содержит прототип объекта) `toString` так, чтобы он возвращал сумму.
Дело в том, что `console.log` неявно использует это свойство, чтобы вывести результат.

# Классы

Объявление классов в JS с помощью ключевого слова `class` это всего лишь "синтаксический сахар". Так как в основе JS лежат прототипы а не классы. Новый синтаксис не добавляет никаких новых структур данных или понятий.

Именовать классы принято с буквы верхнего регистра.

## Объявление класса, конструкторы


Объявление класса синтаксис пример:

```javascript
	class Rectangle {
	  constructor(height, width) {
	    this.height = height;
	    this.width = width;
	  }
	}
```

пример #2:
```javascript
class Animal {

	constructor(name, voice) {
		this.name = name;
		this.voice = voice;
	}

	say() {
		console.log(this.name, 'goes', this.voice);
	}
}

```

Определение методов в классе:
```javascript
	class Example {

	  exampleFunction() {
	    console.log('Example');
	  }
	  exampleFunction2(a) {
	    return a * 2;
	  }
	}
```
Или в виде функций-стрелок (с использованием экспериментального синтаксиса полей класса):
```javascript
	class ExampleArrowFunctions {

	  exampleFunction = () => {
	    console.log('Example');
	  }
	  exampleFunction2 = (a) => {
	    return a * 2;
	  }
	}
```

## Наследование классов


Если нужно произвести наследование какого-либо класса, то применяется ключевое слово `extends` при объявлении дочернего:

```javascript

	class Animal {

		constructor(name, voice) {
			this.name = name;
			this.voice = voice;
		}

		say() {
			console.log(this.name, 'goes', this.voice);
		}
	}

	//наследуем Animal
	class Bird extends Animal {
		//если явно не указать конструктор, то дочерний класс наследует конструктор родительского класса (суперкласса)

	}

	//Цепочка прототипов: duck -> Bird.prototype -> Animal.prototype -> Object.prototype -> null
	const duck = new Bird('Duck', 'quack');

	duck.say();


```

Если нужно в дочернем классе расширить свойства:

```javascript

	class Animal {

		constructor(name, voice) {
			this.name = name;
			this.voice = voice;
		}

		say() {
			console.log(this.name, 'goes', this.voice);
		}
	}
	//наследуем Animal
	class Bird extends Animal {
		//если класс наследует другой класс, то в конструкторе обязательным
		//является вызов конструктора суперкласса
		constructor(name, voice, canFly) {
			super(name, voice); //вызов конструктора суперкласса с передаваемыми параметрами
			//также при наследовании класса обязательным является вызов суперконструктора
			//до того как мы первый раз используем ключевое слово this
			this.canFly = canFly;
		}
	}
	const duck = new Bird('Duck', 'quack', true);
	duck.say();
```

Ключевое слово `super` также предоставляет доступ к любому методу, объявленному в суперклассе.

##	Свойства классов | Class properties

Class properties новый синтаксис, который позволяет инициализировать свойства прямо в теле класса.

Пример:

```javascript
	class Counter {
		//не создавая конструктор
		//удобоно когда свойства не зависят от внешних параметров
		count = 1;

		//функция определяемая таким образом будет автоматически привязана к объекту

		inc = () => {
			this.count++;
			console.log(this.count);
		}
	}
	//будет инициализирован несмотря на отсутствие конструктора в классе
	const cnt = new Counter();
	console.log(cnt.count);
	cnt.inc();
	setTimeout(cnt.inc, 1000);
	//out: 1
	//out: 2
	//out: 3
```

##	Приватные и защищённые методы и свойства | Static

В JavaScript есть два типа полей (свойств и методов) объекта:

* Публичные: доступны отовсюду. Они составляют внешний интерфейс.
* Приватные: доступны только внутри класса. Они для внутреннего интерфейса.


### Защищенные поля

Защищённые поля не реализованы в JavaScript на уровне языка, но на практике они очень удобны, поэтому их эмулируют.

Пример на класса "кофемашины":

```javascript
class CoffeeMachine {
  waterAmount = 0; // количество воды внутри

  constructor(power) {
    this.power = power;
    alert( `Создана кофеварка, мощность: ${power}` );
  }

}

// создаём кофеварку
let coffeeMachine = new CoffeeMachine(100);

// добавляем воды
coffeeMachine.waterAmount = 200;
```
Прямо сейчас свойства `waterAmount` и `power` публичные. Мы можем легко получать и устанавливать им любое значение извне.

Теперь защищаем свойство `waterAmount` (обычно начинаются с префикса _ )

```javascript
class CoffeeMachine {
  _waterAmount = 0;

  set waterAmount(value) {
    if (value < 0) throw new Error("Отрицательное количество воды");
    this._waterAmount = value;
  }

  get waterAmount() {
    return this._waterAmount;
  }

  constructor(power) {
    this._power = power;
  }

}

// создаём новую кофеварку
let coffeeMachine = new CoffeeMachine(100);

// устанавливаем количество воды
coffeeMachine.waterAmount = -10; // Error: Отрицательное количество воды
```

Свойство только для чтения можно задать через геттер (см. в данном справочнике отдельно). Для класса также можно создавать геттеры:
```javascript
class CoffeeMachine {
  // ...

  constructor(power) {
    this._power = power;
  }

  get power() {
    return this._power;
  }

}

// создаём кофеварку
let coffeeMachine = new CoffeeMachine(100);

alert(`Мощность: ${coffeeMachine.power}W`); // Мощность: 100W

coffeeMachine.power = 25; // Error (no setter)
```

### Приватные поля

Есть новшество в языке JavaScript, которое почти добавлено в стандарт: оно добавляет поддержку приватных свойств и методов.

Приватные свойства и методы должны начинаться с `#`. Они доступны только внутри класса.

Например, в классе ниже есть приватное свойство `#waterLimit` и приватный метод `#checkWater` для проверки количества воды:
```javascript
class CoffeeMachine {
  #waterLimit = 200;

  #checkWater(value) {
    if (value < 0) throw new Error("Отрицательный уровень воды");
    if (value > this.#waterLimit) throw new Error("Слишком много воды");
  }
}

let coffeeMachine = new CoffeeMachine();

// снаружи  нет доступа к приватным методам класса
coffeeMachine.#checkWater(); // Error
coffeeMachine.#waterLimit = 1000; // Error
```

Приватные поля не конфликтуют с публичными. У нас может быть два поля одновременно – приватное #waterAmount и публичное waterAmount.

В отличие от защищённых, функциональность приватных полей обеспечивается самим языком. Это хорошо.

### Статические свойства и методы |

Ключевое слово `static` используется для задания свойств, которые принадлежат классу, а не ее `prototype`. Обычно статические методы используются для реализации функций, принадлежащих классу, но не к каким-то конкретным его объектам.

Пример статического метода:
```javascript
class User {
  static staticMethod() {
    alert(this === User);
  }
}

User.staticMethod(); // true
```

Пример статического свойства и метода:
```javascript
	class Counter {

		count = 1;

		inc = () => {
			this.count += Counter.incStep;
			console.log(this.count);
		}

		//статическое поле
		static incStep = 2;

		//статическая функция
		static incrementAll = function(arr) {
			arr.forEach((c) => c.inc());
		};
	}

	//таким образом статическую функцию можно использовать снаружи класса
	Counter.incrementAll([]);

```

Для сравнения код, написанные с использованием действующего сейчас стандарта:

```javascript
	class Counter {
		constructor() {
			this.count = 0;
			this.increment = () => {
				this.count += Counter.incStep;
			}
		}
	}

	//static вынесен за пределы класса
	Counter.incStep = 2;

	Counter.incrementAll = function(arr) {
	arr.forEach((c) => c.inc());
```

Статические свойства и методы наследуются.



#	Модули в JavaScript

Экспорт сущностей из файла определяется ключевым словом `export`.

Например, есть js-файл с именем `helper.js`:

```javascript
	const divide = (a, b) => {
		return a/b;
	}

	class Graph {
		addNode() {
			console.log('node added');
		}
	}

	const PI = 3.1415;

	const forThisFile = 'someValue';

	//экспортируем сущности
	export {
		divide, Graph, PI
	};
```

В файле, где нужны сущности из другого файла импорт сущностей
выполняется через ключевое слово `import`:

```javascript
	//определяем зависимость, импортируем сущности
	import {divide, PI} from './helper';

	console.log(divide(2, 2));
	//out: 1
```
Если нужно модули использовать в браузере.
Так как модули поддерживают ряд специальных ключевых слов, и у них есть ряд особенностей, то необходимо явно сказать браузеру, что скрипт является модулем, при помощи атрибута <script type="module">.

Вот так:

<script type="module">
  import {sayHi} from './say.js';

  document.body.innerHTML = sayHi('John');
</script>


также импортированные сущности можно переименовывать:

```javascript

	import {divide as dvd, PI} from './helper';

	console.log(dvd(2, 2));

```

Переименовывать сущности можно и для экспорта.

Если нужно импортировать все:

```javascript
	import * as helper from './helper';

	console.log(helper.divide(2, 2));
```

Дефолтный экспорт:

```javascript
	//...

	export {
		divide, Graph, PI
	};

	export default Graph;
```

Чтобы получить дефолтный экспорт:

```javascript
	import Graph from './helper';

```

Импорты можно смешивать:

```javascript
	import Graph, {divide, PI} from './helper';

```

Также дефолтный эспорт можно задавать напрямую напротив нужного класса:

```javascript
	export default class Graph {
			addNode() {
				console.log('node added');
			}
		}
```

импорт глобальной зависимости из глобальной библиотеки

```javascript
	import React from 'react';

```

Если модуль импортируется в нескольких файлах, то код модуля будет выполнен только один раз, объект `admin`будет создан и в дальнейшем будет передан всем импортёрам.

Все импортёры получат один-единственный объект `admin`:
```javascript
// 📁 admin.js
export let admin = {
  name: "Ivan"
};
```
```javascript
// 📁 1.js
import {admin} from './admin.js';
admin.name = "Alexandr";
```
```javascript
// 📁 2.js
import {admin} from './admin.js';
alert(admin.name); // Alexandr

// Оба файла, 1.js и 2.js, импортируют один и тот же объект
// Изменения, сделанные в 1.js, будут видны в 2.js
```

Модуль выполняется только один раз. Генерируется экспорт и после передаётся всем импортёрам, поэтому, если что-то изменится в объекте admin, то другие модули тоже увидят эти изменения.

Такое поведение позволяет конфигурировать модули при первом импорте. Мы можем установить его свойства один раз, и в дальнейших импортах он будет уже настроенным.

# События | Event

Интерфейс `Event` представляет собой любое событие, которое происходит в `DOM`; некоторые из них генерируемые пользователем (клик мышью или нажатие клавиши на клавиатуре), а некоторые - генерируемые API (события, обозначающие завершение процесса анимации, приостановка видео и т.д.). Существует много типов событий, некоторые из них используют интерфейсы, базирующиеся на главном интерфейсе Event. Event содержит общие свойства и методы для всех событий.


список часто используемых DOM-событий:

* `click` – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).
* `contextmenu` – происходит, когда кликнули на элемент правой кнопкой мыши.
* `mouseover` / `mouseout` – когда мышь наводится на / покидает элемент.
* `mousedow` / `mouseup` – когда нажали / отжали кнопку мыши на элементе.
* `mousemove` – при движении мыши.

События на элементах управления:

* `submit` – пользователь отправил форму <form>.
* `focus` – пользователь фокусируется на элементе, например нажимает на <input>.

События на элементах управления:

* `submit` – пользователь отправил форму <form>.
* `focus` – пользователь фокусируется на элементе, например нажимает на <input>.


## Обработчики событий | Event Listeners

Событию можно назначить обработчик, то есть функцию, которая сработает, как только событие произошло.

* Обработчик может быть назначен прямо в разметке, в атрибуте, который называется on<событие>.

Например, чтобы назначить обработчик события `click` на элементе `input`, можно использовать атрибут `onclick`, вот так:

<input value="Нажми меня" onclick="alert('Клик!')" type="button">

* Атрибут HTML-тега – не самое удобное место для написания большого количества кода, поэтому лучше создать отдельную JavaScript-функцию и вызвать её там.

Например:

<script>
  function countRabbits() {
    for(let i=1; i<=3; i++) {
      alert("Кролик номер " + i);
    }
  }
</script>

<input type="button" onclick="countRabbits()" value="Считать кроликов!">

* Можно назначать обработчик, используя свойство DOM-элемента on<событие>.


К примеру, `elem.onclick`:


<input id="elem" type="button" value="Нажми меня!">
<script>
  elem.onclick = function() {
    alert('Спасибо');
  };
</script>


Обработчик всегда хранится в свойстве DOM-объекта, а атрибут – лишь один из способов его инициализации.


* обработчиком можно назначить и уже существующую функцию:

```javascript
function sayThanks() {
  alert('Спасибо!');
}

elem.onclick = sayThanks;
```

* Назначение обработчика события через `addEventListener`

пример:
```javascript
//назначить элементу функцию-обработчки события click
input.onclick = function() { alert(1); }
```

Синтаксис:
```javascript
element.addEventListener(event, handler[, options]);
```
`event` - имя события, например "click".
`handler` - ссылка на функцию-обработчик.
`options`
    Дополнительный объект со свойствами:

        once: если true, тогда обработчик будет автоматически удалён после выполнения.
        capture: фаза, на которой должен сработать обработчик, подробнее об этом будет рассказано в главе Всплытие и погружение. Так исторически сложилось, что options может быть false/true, это тоже самое, что {capture: false/true}.
        passive: если true, то указывает, что обработчик никогда не вызовет preventDefault(), подробнее об этом будет рассказано в главе Действия браузера по умолчанию.

Метод `addEventListener` позволяет добавлять несколько обработчиков на одно событие одного элемента, например:


<input id="elem" type="button" value="Нажми меня"/>

<script>
  function handler1() {
    alert('Спасибо!');
  };

  function handler2() {
    alert('Спасибо ещё раз!');
  }

  elem.onclick = () => alert("Привет");
  elem.addEventListener("click", handler1); // Спасибо!
  elem.addEventListener("click", handler2); // Спасибо ещё раз!
</script>

При нажатии на кнопку в примере выше последовательно выполнится три обработчика события.

Для удаления обработчика следует использовать removeEventListener:
```javascript
element.removeEventListener(event, handler[, options]);
```
Удалить можно только неанонимную функцию-обработчик, ранее объявленную.

Для удаления нужно передать именно ту функцию-обработчик которая была назначена.

### Доступ к элементу через this

Внутри обработчика события `this` ссылается на текущий элемент, то есть на тот, на котором, как говорят, «висит» (т.е. назначен) обработчик.

В коде ниже button выводит своё содержимое, используя this.innerHTML:

<button onclick="alert(this.innerHTML)">Нажми меня</button>

## Объект события | event

Чтобы хорошо обработать событие, могут понадобиться детали того, что произошло. Не просто «клик» или «нажатие клавиши», а также – какие координаты указателя мыши, какая клавиша нажата и так далее.

Когда происходит событие, браузер создаёт объект события, записывает в него детали и передаёт его в качестве аргумента функции-обработчику.

Пример ниже демонстрирует использование объекта события:

<input type="button" value="Нажми меня" id="elem">

<script>
  elem.onclick = function(event) {
    // вывести тип события, элемент и координаты клика
    alert(event.type + " на " + event.currentTarget);
    alert("Координаты: " + event.clientX + ":" + event.clientY);
  };
</script>

Свойства объекта `event`:

`event.type` - тип события

`event.currentTarget` - элемент, на котором сработал обработчик. Значение – обычно такое же, как и у this, но если обработчик является функцией-стрелкой или при помощи bind привязан другой объект в качестве this, то мы можем получить элемент из event.currentTarget.

`event.clientX` и `event.clientY` - координаты курсора в момент клика (относительно окна)


Объект события доступен и в HTML

При назначении обработчика в HTML, тоже можно использовать переменную event, это будет работать кросс-браузерно:


<input type="button" onclick="alert(event.type)" value="Тип события">


Это возможно потому, что когда браузер из атрибута создаёт функцию-обработчик, то она выглядит так:
```javascript
function(event) { alert(event.type) };
```
То есть, её первый аргумент называется "event".

В качестве обработчика события методом addEventListener можно назначить и класс:

<button id="elem">Нажми меня</button>

<script>
  class Menu {
    handleEvent(event) {
      switch(event.type) {
        case 'mousedown':
          elem.innerHTML = "Нажата кнопка мыши";
          break;
        case 'mouseup':
          elem.innerHTML += "...и отжата.";
          break;
      }
    }
  }

  let menu = new Menu();
  elem.addEventListener('mousedown', menu);
  elem.addEventListener('mouseup', menu);
</script>

Здесь один и тот же объект обрабатывает оба события. Обратите внимание, мы должны явно назначить оба обработчика через `addEventListener`. Тогда объект `menu` будет получать события `mousedown` и `mouseup`, но не другие (не назначенные) типы событий.


Метод `handleEvent` не обязательно должен выполнять всю работу сам. Он может вызывать другие методы, которые заточены под обработку конкретных типов событий, вот так:


<button id="elem">Нажми меня</button>

<script>
  class Menu {
    handleEvent(event) {
      // mousedown -> onMousedown
      let method = 'on' + event.type[0].toUpperCase() + event.type.slice(1);
      this[method](event);
    }

    onMousedown() {
      elem.innerHTML = "Кнопка мыши нажата";
    }

    onMouseup() {
      elem.innerHTML += "...и отжата.";
    }
  }

  let menu = new Menu();
  elem.addEventListener('mousedown', menu);
  elem.addEventListener('mouseup', menu);
</script>


`event.currentTarget` используется, когда один и тот же обработчик события присваивается нескольким элементам.
```javascript
function hide(e){
  e.currentTarget.style.visibility = "hidden";
  // Когда данная функция используется в качестве обработчика события: this === e.currentTarget
}

const ps = document.getElementsByTagName('p');

for(let i = 0; i < ps.length; i++){
  ps[i].addEventListener('click', hide, false);
}
```
## Всплытие

Этот обработчик для <div> сработает, если вы кликните по любому из вложенных тегов, будь то <em> или <code>:

<div onclick="alert('Обработчик!')">
  <em>Если вы кликните на <code>EM</code>, сработает обработчик на <code>DIV</code></em>
</div>


Принцип всплытия - когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.


Например, есть 3 вложенных элемента FORM > DIV > P с обработчиком на каждом:

<style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form onclick="alert('form')">FORM
  <div onclick="alert('div')">DIV
    <p onclick="alert('p')">P</p>
  </div>
</form>


Клик по внутреннему <p> вызовет обработчик `onclick`:

1. Сначала на самом <p>.
2. Потом на внешнем <div>.
3. Затем на внешнем <form>.
4. И так далее вверх по цепочке до самого `document`.

Этот процесс называется **«всплытием»**, потому что события «всплывают» от внутреннего элемента вверх через родителей подобно тому, как всплывает пузырёк воздуха в воде.


Почти все события всплывают.

Ключевое слово в этой фразе – «почти».

Например, событие `focus` не всплывает. В дальнейшем мы увидим и другие примеры. Однако, стоит понимать, что это скорее исключение, чем правило, всё-таки большинство событий всплывают.


## event.target

Всегда можно узнать, на каком конкретно элементе произошло событие.

Самый глубокий элемент, который вызывает событие, называется целевым элементом, и он доступен через `event.target`.

Отличия от `this` (=`event.currentTarget`):

`event.target` – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен.
`this` – это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.

Например, если стоит только один обработчик `form.onclick`, то он «поймает» все клики внутри формы. Где бы ни был клик внутри –- он всплывёт до элемента <form>, на котором сработает обработчик.

При этом внутри обработчика `form.onclick`:

`this` (=`event.currentTarget`) всегда будет элемент <form>, так как обработчик сработал на ней.
`event.target` будет содержать ссылку на конкретный элемент внутри формы, на котором произошёл клик.

Пример:

<body>
  Клик покажет оба: и <code>event.target</code>, и <code>this</code> для сравнения:

  <form id="form">FORM
    <div>DIV
      <p>P</p>
    </div>
  </form>

  <script src="script.js"></script>

script.js:
```javascript
form.onclick = function(event) {
  event.target.style.backgroundColor = 'yellow';

  // браузеру нужно некоторое время, чтобы зарисовать всё жёлтым
  setTimeout(() => {
    alert("target = " + event.target.tagName + ", this=" + this.tagName);
    event.target.style.backgroundColor = ''
  }, 0);
};
```

## Прекращение всплытия

Всплытие идёт с «целевого» элемента прямо наверх. По умолчанию событие будет всплывать до элемента <html>, а затем до объекта `document`, а иногда даже до `window`, вызывая все обработчики на своём пути.

Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие.

Для этого нужно вызвать метод `event.stopPropagation()`.

Например, здесь при клике на кнопку <button> обработчик `body.onclick` не сработает:


<body onclick="alert(`сюда всплытие не дойдёт`)">
  <button onclick="event.stopPropagation()">Кликни меня</button>
</body>


`event.stopImmediatePropagation()`

Если у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены.

То есть, `event.stopPropagation()` препятствует продвижению события дальше, но на текущем элементе все обработчики будут вызваны.

Для того, чтобы полностью остановить обработку, существует метод `event.stopImmediatePropagation()`. Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.


## Погружение

Существует ещё одна фаза из жизненного цикла события – «погружение» (иногда её называют «перехват»). Она очень редко используется в реальном коде, однако тоже может быть полезной.

Стандарт DOM Events описывает 3 фазы прохода события (их инициирует само возникшее событие на целевом элементе):

* Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.
* Фаза цели (target phase) – событие достигло целевого(исходного) элемента.
* Фаза всплытия (bubbling stage) – событие начинает всплывать.


То есть при клике на какой-либо вложенный дочерний элемент событие путешествует по цепочке родителей сначала вниз к элементу (погружается), затем оно достигает целевой элемент (фаза цели), а потом идёт наверх (всплытие), вызывая по пути обработчики.

Обработчики, добавленные через on<event>-свойство или через HTML-атрибуты, или через `addEventListener(event, handler)` с двумя аргументами, ничего не знают о фазе погружения, а работают только на 2-ой и 3-ей фазах.

Чтобы поймать событие на стадии погружения, нужно использовать третий аргумент capture вот так:
```javascript
elem.addEventListener(..., {capture: true})
// или просто "true", как сокращение для {capture: true}
elem.addEventListener(..., true)
```

Существуют два варианта значений опции capture:

Если аргумент false (по умолчанию), то событие будет поймано при всплытии.
Если аргумент true, то событие будет перехвачено при погружении.

Пример, демонстрирующий особенности всплытия и погружения:
<style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form>FORM
  <div>DIV
    <p>P</p>
  </div>
</form>

<script>
  for(let elem of document.querySelectorAll('*')) {
    elem.addEventListener("click", e => alert(`Погружение: ${elem.tagName}`), true);
    elem.addEventListener("click", e => alert(`Всплытие: ${elem.tagName}`));
  }
</script>

Существует свойство `event.eventPhase`, содержащее номер фазы, на которой событие было поймано. Но оно используется редко, мы обычно и так знаем об этом в обработчике.

Итого
---

При наступлении события – самый глубоко вложенный элемент, на котором оно произошло, помечается как «целевой» (`event.target`).

* Затем событие сначала двигается вниз от корня документа к `event.target`, по пути вызывая обработчики, поставленные через `addEventListener(...., true)`, где `true` – это сокращение для `{capture: true}`.
* Далее обработчики вызываются на целевом элементе.
* Далее событие двигается от event.target вверх к корню документа, по пути вызывая обработчики, поставленные через on<event> и `addEventListener` без третьего аргумента или с третьим аргументом равным `false`.

Каждый обработчик имеет доступ к свойствам события event:

* `event.target` – самый глубокий элемент, на котором произошло событие.
* `event.currentTarget` (=`this`) – элемент, на котором в данный момент сработал обработчик (тот, на котором «висит» конкретный обработчик)
* `event.eventPhase` – на какой фазе он сработал (погружение=1, фаза цели=2, всплытие=3).


## Делегирование событий

Всплытие и перехват событий позволяет реализовать один из самых важных приёмов разработки – делегирование.

Идея в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому, мы ставим один обработчик на их общего предка.

Из него можно получить целевой элемент event.target, понять на каком именно потомке произошло событие и обработать его.

Например, есть таблица:

<table>
  <tr>
    <th colspan="3">Квадрат <em>Bagua</em>: Направление, Элемент, Цвет, Значение</th>
  </tr>
  <tr>
    <td>...<strong>Северо-Запад</strong>...</td>
    <td>...</td>
    <td>...</td>
  </tr>
  <tr>...ещё 2 строки такого же вида...</tr>
  <tr>...ещё 2 строки такого же вида...</tr>
</table>

Наша задача – реализовать подсветку ячейки <td> при клике.

Вместо того, чтобы назначать обработчик onclick для каждой ячейки <td> (их может быть очень много) – мы повесим «единый» обработчик на элемент <table>.

Он будет использовать event.target, чтобы получить элемент, на котором произошло событие, и подсветить его.
```javascript
let selectedTd;

table.onclick = (event) => {
  let target = event.target; // где был клик?

  if (target.tagName != 'TD') return; // не на TD? тогда не интересует

  highlight(target); // подсветить TD
};

const highlight = (td) => {
	selectedTd = td;
  if (selectedTd) { // убрать существующую подсветку, если есть
    selectedTd.classList.remove('highlight');
  }
  selectedTd.classList.add('highlight'); // подсветить новый td
}
```

Такому коду нет разницы, сколько ячеек в таблице. Мы можем добавлять, удалять <td> из таблицы динамически в любое время, и подсветка будет стабильно работать.

Однако, у текущей версии кода есть недостаток.

Клик может быть не на теге <td>, а внутри него.

Внутри обработчика `table.onclick` мы должны по `event.target` разобраться, был клик внутри <td> или нет.

Вот улучшенный код:
```javascript
table.onclick = (event) => {
  let td = event.target.closest('td'); // (1)

  if (!td) return; // (2)

  if (!table.contains(td)) return; // (3)

  highlight(td); // (4)
};
```


1. Метод elem.closest(selector) возвращает ближайшего предка, соответствующего селектору. В данном случае нам нужен <td>, находящийся выше по дереву от исходного элемента.
2. Если event.target не содержится внутри элемента <td>, то вызов вернёт null, и ничего не произойдёт.
3. Если таблицы вложенные, event.target может содержать элемент <td>, находящийся вне текущей таблицы. В таких случаях мы должны проверить действительно ли это <td> нашей таблицы.
4. И если это так, то подсвечиваем его.


**Применение делегирования: действия в разметке**

Например, нам нужно сделать меню с разными кнопками: «Сохранить (save)», «Загрузить (load)», «Поиск (search)» и т.д. И есть объект с соответствующими методами save, load, search… Как их состыковать?

Первое, что может прийти в голову – это найти каждую кнопку и назначить ей свой обработчик среди методов объекта. Но существует более элегантное решение. Мы можем добавить один обработчик для всего меню и атрибуты data-action для каждой кнопки в соответствии с методами, которые они вызывают:

<button data-action="save">Нажмите, чтобы Сохранить</button>

Обработчик считывает содержимое атрибута и выполняет метод. Взгляните на рабочий пример:

<div id="menu">
  <button data-action="save">Сохранить</button>
  <button data-action="load">Загрузить</button>
  <button data-action="search">Поиск</button>
</div>

<script>
  class Menu {
    constructor(elem) {
      this._elem = elem;
      elem.onclick = this.onClick.bind(this); // (*)
    }

    save() {
      alert('сохраняю');
    }

    load() {
      alert('загружаю');
    }

    search() {
      alert('ищу');
    }

    onClick(event) {
      let action = event.target.dataset.action;
      if (action) {
        this[action]();
      }
    };
  }

  new Menu(menu);
</script>

Обратите внимание, что метод `this.onClick` в строке, отмеченной звёздочкой ( * ), привязывается к контексту текущего объекта `this`. Это важно, т.к. иначе `this` внутри него будет ссылаться на DOM-элемент (`elem`), а не на объект `Menu`, и `this[action]` будет не тем, что нам нужно.

**Приём проектирования «поведение»**


Приём проектирования «поведение» состоит из двух частей:

1. Элементу ставится пользовательский атрибут, описывающий его поведение.
2. При помощи делегирования ставится обработчик на документ, который ловит все клики (или другие события) и, если элемент имеет нужный атрибут – производит соответствующее действие.


Например, здесь HTML-атрибут data-counter добавляет кнопкам поведение: «увеличить значение при клике»:

Счётчик: <input type="button" value="1" data-counter>
Ещё счётчик: <input type="button" value="2" data-counter>

<script>
  document.addEventListener('click', function(event) {

    if (event.target.dataset.counter != undefined) { // если есть атрибут...
      event.target.value++;
    }

  });
</script>

Элементов с атрибутом `data-counter` может быть сколько угодно. Новые могут добавляться в HTML-код в любой момент. При помощи делегирования мы, фактически, добавили новый «псевдостандартный» атрибут в HTML, который добавляет элементу новую возможность («поведение»).


Всегда используйте метод `addEventListener` для обработчиков на уровне документа

Когда мы устанавливаем обработчик событий на объект document, мы всегда должны использовать метод `addEventListener`, а не `document.on<событие>`, т.к. в случае последнего могут возникать конфликты: новые обработчики будут перезаписывать уже существующие.

Для реального проекта совершенно нормально иметь много обработчиков на элементе document, установленных из разных частей кода.


**Поведение: «Переключатель» (Toggler)**

Ещё один пример поведения. Сделаем так, что при клике на элемент с атрибутом data-toggle-id будет скрываться/показываться элемент с заданным id:

<button data-toggle-id="subscribe-mail">
  Показать форму подписки
</button>

<form id="subscribe-mail" hidden>
  Ваша почта: <input type="email">
</form>

<script>
  document.addEventListener('click', (event) => {
    let id = event.target.dataset.toggleId;
    if (!id) return;

    let elem = document.getElementById(id);

    elem.hidden = !elem.hidden;
  });
</script>

В атрибут элемента, генерирующего событие добавлен атрибут `data-toggle-id`, значение у которого это id целевого элемента, на который он должен повлиять при выполнении определенного события.

**Итого**

Делегирование событий – это один из самых полезных приёмов для работы с DOM.

Он часто используется, если есть много элементов, обработка которых очень схожа, но не только для этого.

Алгоритм:

1. Вешаем обработчик на контейнер.
2. В обработчике проверяем исходный элемент event.target.
3. Если событие произошло внутри нужного нам элемента, то обрабатываем его.


## Действия браузера по умолчанию | event.preventDefault()

Многие события автоматически влекут за собой действие браузера.

Например:

*   Клик по ссылке инициирует переход на новый URL.
*   Нажатие на кнопку «отправить» в форме – отсылку её на сервер.
*   Зажатие кнопки мыши над текстом и её движение в таком состоянии – инициирует его выделение.

Если мы обрабатываем событие в JavaScript, то зачастую такое действие браузера нам не нужно. К счастью, его можно отменить.


Отмена действия браузера

Есть два способа отменить действие браузера:

*    Основной способ – это воспользоваться объектом `event`. Для отмены действия браузера существует стандартный метод `event.preventDefault()`.
*    Если же обработчик назначен через `on<событие>` (не через `addEventListener`), то также можно вернуть `false` из обработчика.

В следующем примере при клике по ссылке переход не произойдёт:

<a href="/" onclick="return false">Нажми здесь</a>
или
<a href="/" onclick="event.preventDefault()">здесь</a>

Рассмотрим меню для сайта, например:

<ul id="menu" class="menu">
  <li><a href="/html">HTML</a></li>
  <li><a href="/javascript">JavaScript</a></li>
  <li><a href="/css">CSS</a></li>
</ul>

В HTML-разметке все элементы меню являются не кнопками, а ссылками, то есть тегами <a>. В этом подходе есть некоторые преимущества, например:

*    Некоторые посетители очень любят сочетание «правый клик – открыть в новом окне». Если мы будем использовать <button> или <span>, то данное сочетание работать не будет.
*    Поисковые движки переходят по ссылкам <a href="..."> при индексации.

Поэтому в разметке мы используем <a>. Но нам необходимо обрабатывать клики в JavaScript, а стандартное действие браузера (переход по ссылке) – отменить.

Например, вот так:
```javascript
menu.addEventListener('click', (event) => {
  if (event.target.nodeName != 'A') return;

  let href = event.target.getAttribute('href');
  alert( href ); // может быть подгрузка с сервера, генерация интерфейса и т.п.

  return false; // отменить действие браузера (переход по ссылке)
});
```
или так:
```javascript
menu.addEventListener('click', (event) => {
  event.preventDefault(); //отмена действия браузера по умолчанию
  if (event.target.nodeName != 'A') return;

  let href = event.target.getAttribute('href');
  alert( href ); // может быть подгрузка с сервера, генерация интерфейса и т.п.

});
```


Если мы уберём `return false`, то после выполнения обработчика события браузер выполнит «действие по умолчанию» – переход по адресу из `href`. А это нам здесь не нужно, мы обрабатываем клик сами.

**Свойство event.defaultPrevented**

Свойство `event.defaultPrevented` установлено в `true`, если действие по умолчанию было предотвращено, и `false`, если нет.

Давайте посмотрим практический пример.

По умолчанию браузер при событии contextmenu (клик правой кнопкой мыши) показывает контекстное меню со стандартными опциями. Мы можем отменить событие по умолчанию и показать своё меню, как здесь:

<button>Правый клик вызывает контекстное меню браузера</button>

<button oncontextmenu="alert('Рисуем наше меню'); return false">
  Правый клик вызывает наше контекстное меню
</button>

Теперь в дополнение к этому контекстному меню реализуем контекстное меню для всего документа.

При правом клике должно показываться ближайшее контекстное меню.

<p>Правый клик здесь вызывает контекстное меню документа</p>
<button id="elem">Правый клик здесь вызывает контекстное меню кнопки</button>

<script>
  elem.oncontextmenu = (event) => {
    event.preventDefault();
    alert("Контекстное меню кнопки");
  };

  document.oncontextmenu = (event) => {
    event.preventDefault();
    alert("Контекстное меню документа");
  };
</script>


Проблема заключается в том, что когда мы кликаем по элементу `elem`, то мы получаем два меню: контекстное меню для кнопки и (событие всплывает вверх) контекстное меню для документа.

Для кнопки можно использовать `event.stopPropagation();`

Но цена слишком высока. Мы навсегда запретили доступ к информации о правых кликах для любого внешнего кода, включая счётчики, которые могли бы собирать статистику, и т.п.

Альтернативным решением было бы проверить в обработчике document, было ли отменено действие по умолчанию? Если да, тогда событие было обработано, и нам не нужно на него реагировать.

<p>Правый клик вызывает меню документа (добавлена проверка event.defaultPrevented)</p>
<button id="elem">Правый клик вызывает меню кнопки</button>

<script>
  elem.oncontextmenu = (event) => {
    event.preventDefault();
    alert("Контекстное меню кнопки");
  };

  document.oncontextmenu = (event) => {
    if (event.defaultPrevented) return;

    event.preventDefault();
    alert("Контекстное меню документа");
  };
</script>

Итого

Действий браузера по умолчанию достаточно много:

*    `mousedown` – начинает выделять текст (если двигать мышкой).
*    `click` на <input type="checkbox"> – ставит или убирает галочку в input.
*    `submit` – при нажатии на <input type="submit"> или при нажатии клавиши Enter в форме данные отправляются на сервер.
*    `keydown` – при нажатии клавиши в поле ввода появляется символ.
*    `contextmenu` – при правом клике показывается контекстное меню браузера.
    …и многие другие…


# Callbacks

Колбэками называются функции которые должны быть выполнены **после** того, как другая функция завершила свою работу.
Колбэки (наряду с промисами и асинхронными функциями) используются в JavaScript из-за его асинхронности и событийно-ориентированности. Т.е. иногда, когда требуется выполнение нескольких функций последовательно и при этом, для второй функции требуется результат выполнения первой, если не использовать колбэки (или другие инструменты), первая функция может не успеть отработать до момента вызова второй.

Пример простого колбэка:

```javascript
const doHomework = (subject, callback) => {
  alert(`Starting my ${subject} homework.`);
  //Вызываем колбэк после завершения работы предыдущей функции
  callback();
}

const alertFinished = () => {
  alert('Finished my homework');
}

doHomework('math', alertFinished);

```


# Замыкание

Мы знаем, что функция может получить доступ к переменным из внешнего окружения, эта возможность используется очень часто.

Но что произойдёт, когда внешние переменные изменятся? Функция получит последнее значение или то, которое существовало на момент создания функции?

И что произойдёт, когда функция переместится в другое место в коде и будет вызвана оттуда – получит ли она доступ к внешним переменным своего нового местоположения?

Пример:

Функция sayHi использует внешнюю переменную name. Какое значение будет использовать функция при выполнении?
```javascript
let name = "John";

function sayHi() {
  alert("Hi, " + name);
}

name = "Pete";

sayHi(); // что будет показано: "John" или "Pete"? Ответ Pete так как на момент вызова функции оно уже
//записано в перменную name
```
Такие ситуации распространены и в браузерной и в серверной разработке. Выполнение функции может быть запланировано позже, чем она была создана, например, после какого-нибудь пользовательского действия или сетевого запроса.


## Лексическое Окружение | LexicalEnvironment

В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, называемый лексическим окружением `LexicalEnvironment`.

Объект лексического окружения состоит из двух частей:

1. Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение `this`).

2. Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).

"Переменная" – это просто свойство специального внутреннего объекта: `Environment Record`. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».

Пример работы лексического окружения при объявлении переменной:

let x; [<пусто>] outer_link_ -> null
x = 1; [x: 1]
x = 2; [x: 2]

1. При объявлении переменной в начале выполнения кода лексическое окружение пусто
2. Как только выполнение доходит до объявления `let x`, так как присвоенного значения сразу нет, ей присваивается значение `undefined`
3. Переменной присваивается значение 1
4. У переменной изменяется значение на 2

### Объявление функций | Function Declaration

В отличие от переменных работа лексического окружения при объявлении функций различна.

Если в коде есть объявленная функция, то она при его исполнении инициализируется в лексическом окружении не тогда, когда выполнение до нее доходит, а при создании лексического окружения. Для верхнеуровневых функций это означает момент, когда скрипт начинает выполнение.

Вот почему мы можем вызвать функцию, объявленную через Function Declaration, до того, как она определена.

пример:
*начало выполнения*  				[incremented:functon] outer_link_ -> null
let x = 1;			 				[incremented: function; x: 1]

function incremented(param) {
	alert (param + x);
}

### Внутреннее и внешнее лексическое окружение

При запуске функции для нее создается новое лексическое окружение для хранения локальных переменных и параметров, с которыми функция была вызвана. При этом новое внутреннее лексическое окружение также имеет ссылку (на примерах outer_link_) на внешнее окружение по отношению функции.


```javascript
пример:
*начало выполнения*  			//	[incremented:functon] outer_link_ -> null
let x = 1;			 			//	[incremented: function; x: 1]
									*внутреннее окружение*:
function incremented(param) {	//exe: [param: 2] outer_link_ -> [incremented: function; x: 1] outer_link_ -> null
	alert (param + x);
}

incremented(2);
```

Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального.

Если переменная не была найдена, это будет ошибкой в `strict mode`. Без `strict mode`, для обратной совместимости, присваивание несуществующей переменной создаёт новую глобальную переменную с таким именем.

Вот так происходит выполнение кода из примера выше:

* когда начинает выполняться функция `alert` внутри `incremented` происходит поиск `param` и он немедленно находится во внутреннем лексическом окружении функции `incremented`.
* затем, когда производится попытка получения доступа к `x`, которой нет во внутреннем лексическом окружении, происходит переход по ссылке к внешнему лексическому окружению и переменная найдена.

Функция получает текущее значение внешних переменных, то есть, их **последнее** значение

Старые значения переменных нигде не сохраняются. Когда функция хочет получить доступ к переменной, она берёт её текущее значение из своего или внешнего лексического окружения.

Иллюстрирующий пример:
```javascript
let name = "John";

function sayHi() {
  alert("Hi, " + name);
}

name = "Pete"; // (*)

sayHi(); // Pete
```

Каждый новый вызов функции приводит к созданию нового лексического окружения для нее.

### Вложенные функции

Функция называется «вложенной», когда она создаётся внутри другой функции.

Пример:

```javascript
const makeCounter = () => {
  let count = 0;

  return function() {
    return count++; // есть доступ к внешней переменной "count"
  };
}

let counter = makeCounter();

alert( counter() ); // 0
alert( counter() ); // 1
alert( counter() ); // 2
```

Когда внутренняя функция начинает выполняться, начинается поиск переменной `count` изнутри-наружу. Для примера выше порядок будет такой:

```JavaScript
										      	 //3
const makeCounter = () => {
  let count = 0;
  										//2
  return function() {
    return count++;     	// 1
  };
}
```

1. Локальные переменные вложенной функции…
2. Переменные внешней функции…
3. И так далее, пока не будут достигнуты глобальные переменные.

В этом примере count будет найден на шаге 2. Когда внешняя переменная модифицируется, она изменится там, где была найдена. Значит, `count++` найдёт внешнюю переменную и увеличит её значение в лексическом окружении, которому она принадлежит. Как если бы у нас было `let count = 1.`

Теперь рассмотрим два вопроса:

1. Можем ли мы каким-нибудь образом сбросить счётчик `count` из кода, который не принадлежит `makeCounter`? Например, после вызова `alert` в коде выше.
2. Если мы вызываем `makeCounter` несколько раз – нам возвращается много функций `counter`. Они независимы или разделяют одну и ту же переменную `count`?

Итак:
1. Такой возможности нет: `count` – локальная переменная функции, мы не можем получить к ней доступ извне.
2. Для каждого вызова `makeCounter()` создаётся новое лексическое окружение функции, со своим собственным count. Так что, получившиеся функции `counter` – независимы.

```javascript
function makeCounter() {
  let count = 0;
  return function() {
    return count++;
  };
}

let counter1 = makeCounter();
let counter2 = makeCounter();

alert( counter1() ); // 0
alert( counter1() ); // 1

alert( counter2() ); // 0 (независимо)
```

Более детальное описание


Когда скрипт только начинает выполняться, есть только глобальное лексическое окружение:
```javascript
function makeCounter() { [[Environment]] -> [makeCounter: function] -> outer_link_ null
  let count = 0;
  return function() {
    return count++;
  };
}
```

1. В этот начальный момент есть только функция `makeCounter`, потому что это `Function Declaration`. Она ещё не выполняется.

Все функции «при рождении» получают скрытое свойство `[[Environment]]`, которое ссылается на лексическое окружение места, где они были созданы. Это служит для того, чтобы функции знали то место, в котором они были созданы.

В данном случае, `makeCounter` создан в глобальном лексическом окружении, так что `[[Environment]]` содержит ссылку на него.

Другими словами, функция навсегда запоминает ссылку на лексическое окружение, где она была создана. И `[[Environment]]` – скрытое свойство функции, которое содержит эту ссылку.

2. Код продолжает выполняться, объявляется новая глобальная переменная `counter`, которой присваивается результат вызова `makeCounter`. Вот снимок момента, когда интерпретатор находится на первой строке внутри makeCounter():

```javascript
function makeCounter() { //LexicalEnvironment makeCounter()| глобальное LexicalEnvironment
>> let count = 0;			[count: 0] outer_link_ 		 -> [makeCounter:function; counter: undefined] -> null
  return function() {
    return count++;
  };
}
let counter = makeCounter();
```

3. В процессе выполнения `makeCounter()` создаётся небольшая вложенная функция.

Не имеет значения, какой способ объявления функции используется: Function Declaration или Function Expression. Все функции получают свойство `[[Environment]]`, которое ссылается на лексическое окружение, в котором они были созданы. То же самое происходит и с нашей новой маленькой функцией.

Для нашей новой вложенной функции значением [[Environment]] будет текущее лексическое окружение makeCounter() (где она была создана):

```javascript
function makeCounter() { //LexicalEnvironment makeCounter()| глобальное LexicalEnvironment
 let count = 0;			[count: 0] outer_link_ 		 -> [makeCounter:function; counter: undefined] -> null
>>  return function() {
    return count++;
  };
}
let counter = makeCounter();
```

Пожалуйста, обратите **внимание**, что на этом шаге внутренняя функция была создана, но ещё **не вызвана**. Код внутри `function() { return count++ }` не выполняется.

4. Выполнение продолжается, вызов `makeCounter()` завершается, и результат (небольшая вложенная функция) присваивается глобальной переменной `counter`:

```javascript
function makeCounter() { //LexicalEnvironment makeCounter()| глобальное LexicalEnvironment
 let count = 0;			[count: 0] outer_link_ -> | [makeCounter:function; counter: function] -> null
  return function() {
    return count++;
  };
}
>> let counter = makeCounter();
alert ( counter() );
```

В этой функции есть только одна строчка: return count++, которая будет выполнена, когда мы вызовем функцию.

5. При вызове `counter()` для этого вызова создаётся новое лексическое окружение. Оно пустое, так как в самом `counter` локальных переменных нет. Но `[[Environment]]` `counter` используется, как ссылка на внешнее лексическое окружение outer, которое даёт доступ к переменным предшествующего вызова makeCounter, где `counter` был создан.

```javascript
function makeCounter() { //  counter() |LexicalEnvironment makeCounter()| глобальное LexicalEnvironment
 let count = 0;			  [<empty>] -> | [count: 0] outer_link_ -> | [makeCounter:function;
 																counter: function] -> null
  return function() {
    return count++;
  };
}
let counter = makeCounter();
>> alert ( counter() );
```

Теперь, когда вызов ищет переменную `count`, он сначала ищет в собственном лексическом окружении (пустое), а затем в лексическом окружении предшествующего вызова `makeCounter()`, где и находит её.

Пожалуйста, обратите внимание, как здесь работает управление памятью. Хотя `makeCounter()` закончил выполнение некоторое время назад, его лексическое окружение остаётся в памяти, потому что есть вложенная функция с `[[Environment]]`, который ссылается на него.

В большинстве случаев, объект лексического окружения существует до того момента, пока есть функция, которая может его использовать. И только тогда, когда таких не остаётся, окружение уничтожается.

6. Вызов `counter()` не только возвращает значение `count`, но также увеличивает его. Обратите внимание, что модификация происходит «на месте». Значение `count` изменяется конкретно в том окружении, где оно было найдено.

7. Следующие вызовы `counter()` сделают то же самое.

Объявление переменных ключевым словом `let` делает их областью видимости только определенный блок кода, при поиске их из лексического окружения поиск останавливается сразу как они были найдены (если они внешние по отношению к определенному блоку), в отличие от ключевого слова `var`.

**Замыкание** – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. В некоторых языках это невозможно, или функция должна быть написана специальным образом, чтобы получилось замыкание. Но, как было описано выше, в JavaScript, все функции изначально являются замыканиями (есть только одно исключение "new Function"). То есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства `[[Environment]]` и все они могут получить доступ к внешним переменным.

Лексическое окружение существует не только для функций, но и любых блоков кода, заключенных в `{...}`.

В примере ниже переменная `user` существует только в блоке `if`:
```javascript
let phrase = 'Hello';
if (true) {
	let user = 'John';
	alert (`${phrase}, ${user}`);
}
alert(user); //Error! no such user
```

Все переменные и Function Expression, объявленные внутри `if`, остаются в его лексическом окружении и не видны снаружи.

Для циклов также создается свое лексическое окружение. Например, если в цикле `for` переменная объявлена с помощью `let`:
```javascript
for (let i = 0; i < 10; i++) {
  // У каждой итерации цикла своё собственное лексическое окружение
  // {i: value}
}
alert(i); // Ошибка, нет такой переменной
```
то данная переменная также доступна только в лексическом окружении цикла.

Сборщик мусора не очищает лексическое окружение функции, если у нее несть доступная вложенная функция (например на нее ссылается какая-либо переменная), так как сохраняется ссылка на него.

Для наглядности:

```javascript
function f() {
  let value = 123;

  function g() { alert(value); }

  return g;
}

let g = f(); // пока g существует,
// соответствующее лексическое окружение существует

g = null; // ...а теперь память очищается
```

# Работа с бинарными данными | ArrayBuffer, бинарные массивы, Uint8Array


В сфере веб-разработки мы встречаемся с бинарными данными чаще всего тогда, когда требуется выполнить какие-то действия над файлами (создать, загрузить или скачать). Другим типичным примером такой встречи является обработка изображений.

Всё это возможно осуществить на JavaScript. Более того, операции над бинарными данными являются высокопроизводительными.

Вот некоторые из классов, которые предназначены для работы с бинарными данными:

`ArrayBuffer, Uint8Array, DataView, Blob, File`

Базовый объект для работы с бинарными данными имеет тип `ArrayBuffer` и представляет собой ссылку на непрерывную область памяти фиксированной длины.

Вот так мы можем создать его экземпляр:
```javascript
let buffer = new ArrayBuffer(16); // создаётся буфер длиной 16 байт
alert(buffer.byteLength); // 16
```
Инструкция выше выделяет непрерывную область памяти размером 16 байт и заполняет её нулями.


`ArrayBuffer` – это не массив!

Давайте внесём ясность, чтобы не запутаться. `ArrayBuffer` не имеет ничего общего с Array:

* его длина фиксирована, мы не можем увеличивать или уменьшать её.
* `ArrayBuffer` занимает ровно столько места в памяти, сколько указывается при создании.
* Для доступа к отдельным байтам нужен вспомогательный объект-представление, `buffer[index]` не сработает.

`ArrayBuffer` – это область памяти. Что там хранится? Этой информации нет. Просто необработанный («сырой») массив байтов.


Для работы с `ArrayBuffer` нам нужен специальный объект, реализующий «представление» данных.

Такие объекты не хранят какое-то собственное содержимое. Они интерпретируют бинарные данные, хранящиеся в `ArrayBuffer`.

Например:

* `Uint8Array` – представляет каждый байт в `ArrayBuffer` как отдельное число; возможные значения находятся в промежутке от 0 до 255 (в байте 8 бит, отсюда такой набор). Такое значение называется «8-битное целое без знака».
* `Uint16Array` – представляет каждые 2 байта в `ArrayBuffer` как целое число; возможные значения находятся в промежутке от 0 до 65535. Такое значение называется «16-битное целое без знака».
* `Uint32Array` – представляет каждые 4 байта в `ArrayBuffer` как целое число; возможные значения находятся в промежутке от 0 до 4294967295. Такое значение называется «32-битное целое без знака».
* `Float64Array` – представляет каждые 8 байт в `ArrayBuffer` как число с плавающей точкой; возможные значения находятся в промежутке между 5.0x10-324 и 1.8x10308.


Таким образом, бинарные данные из `ArrayBuffer` размером 16 байт могут быть представлены как 16 чисел маленькой разрядности или как 8 чисел большей разрядности (по 2 байта каждое), или как 4 числа ещё большей разрядности (по 4 байта каждое), или как 2 числа с плавающей точкой высокой точности (по 8 байт каждое).

`ArrayBuffer` – это корневой объект, основа всего, необработанные бинарные данные.

Но если мы собираемся что-то записать в него или пройтись по его содержимому, да и вообще для любых действий мы должны использовать какой-то объект-представление («view»), например:
```javascript
let buffer = new ArrayBuffer(16); // создаётся буфер длиной 16 байт

let view = new Uint32Array(buffer); // интерпретируем содержимое как последовательность 32-битных целых чисел без знака

alert(Uint32Array.BYTES_PER_ELEMENT); // 4 байта на каждое целое число

alert(view.length); // 4, именно столько чисел сейчас хранится в буфере
alert(view.byteLength); // 16, размер содержимого в байтах

// давайте запишем какое-нибудь значение
view[0] = 123456;

// теперь пройдёмся по всем значениям
for(let num of view) {
  alert(num); // 123456, потом 0, 0, 0 (всего 4 значения)
}
```

## TypedArray

Общий термин для всех таких представлений (`Uint8Array`, `Uint32Array` и т.д.) – это `TypedArray`, *типизированный массив*. У них имеется набор одинаковых свойств и методов.

Они уже намного больше напоминают обычные массивы: элементы проиндексированы, и возможно осуществить обход содержимого.

Конструкторы типизированных массивов (будь то `Int8Array` или `Float64Array`, без разницы) ведут себя по-разному в зависимости от типа передаваемого им аргумента.

Есть 5 вариантов создания типизированных массивов:
```javascript
new TypedArray(buffer, [byteOffset], [length]);
new TypedArray(object);
new TypedArray(typedArray);
new TypedArray(length);
new TypedArray();
```



1. Если передан аргумент типа `ArrayBuffer`, то создаётся объект-представление для него. Мы уже использовали этот синтаксис ранее.

Дополнительно можно указать аргументы `byteOffset` (0 по умолчанию) и `length` (до конца буфера по умолчанию), тогда представление будет покрывать только часть данных в buffer.

2. Если в качестве аргумента передан `Array` или какой-нибудь псевдомассив, то будет создан типизированный массив такой же длины и с тем же содержимым.

Мы можем использовать эту возможность, чтобы заполнить типизированный массив начальными данными:
```javascript
let arr = new Uint8Array([0, 1, 2, 3]);
alert( arr.length ); // 4, создан бинарный массив той же длины
alert( arr[1] ); // 1, заполнен 4-мя байтами с указанными значениями
```
3. Если в конструктор передан другой объект типа `TypedArray`, то делается то же самое: создаётся типизированный массив с такой же длиной и в него копируется содержимое. При необходимости значения будут приведены к новому типу.
```javascript
let arr16 = new Uint16Array([1, 1000]);
let arr8 = new Uint8Array(arr16);
alert( arr8[0] ); // 1
alert( arr8[1] ); // 232, потому что 1000 не помещается в 8 бит (разъяснения будут ниже)
```

4. Если передано число `length` – будет создан типизированный массив, содержащий именно столько элементов. Размер нового массива в байтах будет равен числу элементов length, умноженному на размер одного элемента `TypedArray.BYTES_PER_ELEMENT`:
```javascript
let arr = new Uint16Array(4); // создаём типизированный массив для 4 целых 16-битных чисел без знака
alert( Uint16Array.BYTES_PER_ELEMENT ); // 2 байта на число
alert( arr.byteLength ); // 8 (размер массива в байтах)
```


5. При вызове без аргументов будет создан пустой типизированный массив.

Как видим, можно создавать типизированные массивы `TypedArray` напрямую, не передавая в конструктор объект типа `ArrayBuffer`. Но представления не могут существовать сами по себе без двоичных данных, так что на самом деле объект `ArrayBuffer` создаётся автоматически во всех случаях, кроме первого, когда он явно передан в конструктор представления.

Для доступа к `ArrayBuffer` есть следующие свойства:

* `arr.buffer` – ссылка на объект `ArrayBuffer`.
* `arr.byteLength` – размер содержимого `ArrayBuffer` в байтах.

Таким образом, мы всегда можем перейти от одного представления к другому:
```javascript
let arr8 = new Uint8Array([0, 1, 2, 3]);
// другое представление на тех же данных
let arr16 = new Uint16Array(arr8.buffer);
```

Список типизированных массивов:

* `Uint8Array`, `Uint16Array`, `Uint32Array` – целые беззнаковые числа по 8, 16 и 32 бита соответственно.
		** `Uint8ClampedArray` – 8-битные беззнаковые целые, обрезаются по верхней и нижней границе при присвоении (об этом ниже).
* `Int8Array, Int16Array, Int32Array` – целые числа со знаком (могут быть отрицательными).
* `Float32Array, Float64Array` – 32- и 64-битные числа со знаком и плавающей точкой.


Не существует примитивных типов данных `int8` и т.д.

Обратите внимание: несмотря на названия вроде `Int8Array`, в JavaScript нет примитивных типов данных `int` или `int8`.

Это логично, потому что `Int8Array` – это не массив отдельных значений, а представление, основанное на бинарных данных из объекта типа `ArrayBuffer`.

**Что будет, если выйти за пределы допустимых значений?**

Что если мы попытаемся записать в типизированный массив значение, которое превышает допустимое для данного массива? Ошибки не будет. Лишние биты просто будут отброшены.

Например, давайте попытаемся записать число 256 в объект типа `Uint8Array`. В двоичном формате 256 представляется как 100000000 (9 бит), но `Uint8Array` предоставляет только 8 бит для значений. Это определяет диапазон допустимых значений от 0 до 255.

Если наше число больше, то только 8 младших битов (самые правые) будут записаны, а лишние отбросятся:

8-bit integer
1[00000000] 256

Таким образом, вместо 256 запишется 0.

Число 257 в двоичном формате выглядит как 100000001 (9 бит), но принимаются во внимание только 8 самых правых битов, так что в объект будет записана единичка:

8-bit integer
1[00000001] 257

Другими словами, записываются только значения по модулю 28.

Вот демо:
```javascript
let uint8array = new Uint8Array(16);

let num = 256;
alert(num.toString(2)); // 100000000 (в двоичном формате)

uint8array[0] = 256;
uint8array[1] = 257;

alert(uint8array[0]); // 0
alert(uint8array[1]); // 1
```

`Uint8ClampedArray`, упомянутый ранее, ведёт себя по-другому в данных обстоятельствах. В него записываются значения 255 для чисел, которые больше 255, и 0 для отрицательных чисел. Такое поведение полезно в некоторых ситуациях, например при обработке изображений.

## Методы TypedArray

Типизированные массивы `TypedArray`, за некоторыми заметными исключениями, имеют те же методы, что и массивы `Array`.

Мы можем обходить их, вызывать `map`, `slice`, `find`, `reduce` и т.д.

Однако, есть некоторые вещи, которые нельзя осуществить:

* Нет метода `splice` – мы не можем удалять значения, потому что типизированные массивы – это всего лишь представления данных из буфера, а буфер – это непрерывная область памяти фиксированной длины. Мы можем только записать 0 вместо значения.
* Нет метода `concat`.

Но зато есть два дополнительных метода:

* `arr.set(fromArr, [offset])` копирует все элементы из `fromArr` в `arr`, начиная с позиции `offset` (0 по умолчанию).
* `arr.subarray([begin, end])` создаёт новое представление того же типа для данных, начиная с позиции `begin` до `end` (не включая). Это похоже на метод `slice` (который также поддерживается), но при этом ничего не копируется – просто создаётся новое представление, чтобы совершать какие-то операции над указанными данными.

Эти методы позволяют нам копировать типизированные массивы, смешивать их, создавать новые на основе существующих и т.д.


## DataView

`DataView` – это специальное супергибкое нетипизированное представление данных из `ArrayBuffer`. Оно позволяет обращаться к данным на любой позиции и в любом формате.

* В случае типизированных массивов конструктор строго задаёт формат данных. Весь массив состоит из однотипных значений. Доступ к i-ому элементу можно получить как `arr[i]`.
* В случае `DataView` доступ к данным осуществляется посредством методов типа `.getUint8(i)` или `.getUint16(i)`. Мы выбираем формат данных в момент обращения к ним, а не в момент их создания.

Синтаксис:
```javascript
new DataView(buffer, [byteOffset], [byteLength])
```

* `buffer` – ссылка на бинарные данные `ArrayBuffer`. В отличие от типизированных массивов, `DataView` не создаёт буфер автоматически. Нам нужно заранее подготовить его самим.
* `byteOffset` – начальная позиция данных для представления (по умолчанию 0).
* `byteLength` – длина данных (в байтах), используемых в представлении (по умолчанию – до конца buffer).

Например, извлечём числа в разных форматах из одного и того же буфера двоичных данных:
```javascript
// бинарный массив из 4х байт, каждый имеет максимальное значение 255
let buffer = new Uint8Array([255, 255, 255, 255]).buffer;

let dataView = new DataView(buffer);

// получим 8-битное число на позиции 0
alert( dataView.getUint8(0) ); // 255

// а сейчас мы получим 16-битное число на той же позиции 0, оно состоит из 2-х байт, вместе составляющих число 65535
alert( dataView.getUint16(0) ); // 65535 (максимальное 16-битное беззнаковое целое)

// получим 32-битное число на позиции 0
alert( dataView.getUint32(0) ); // 4294967295 (максимальное 32-битное беззнаковое целое)

dataView.setUint32(0, 0); // при установке 4-байтового числа в 0, во все его 4 байта будут записаны нули
```

Представление `DataView` отлично подходит, когда мы храним данные разного формата в одном буфере. Например, мы храним последовательность пар, первое значение пары 16-битное целое, а второе – 32-битное с плавающей точкой. `DataView` позволяет легко получить доступ к обоим.

**Итого**

`ArrayBuffer` – это корневой объект, ссылка на непрерывную область памяти фиксированной длины.

Чтобы работать с объектами типа `ArrayBuffer`, нам нужно представление («view»).

* Это может быть типизированный массив `TypedArray`:
		** `Uint8Array, Uint16Array, Uint32Array` – для беззнаковых целых по 8, 16 и 32 бита соответственно.
		** `Uint8ClampedArray` – для 8-битных беззнаковых целых, которые обрезаются по верхней и нижней границе при присвоении.
		** `Int8Array, Int16Array, Int32Array` – для знаковых целых чисел (могут быть отрицательными).
		** `Float32Array, Float64Array` – для 32- и 64-битных знаковых чисел с плавающей точкой.
* Или `DataView` – представление, использующее отдельные методы, чтобы уточнить формат данных при обращении, например, `getUint8(offset)`.


Обычно мы создаём и работаем с типизированными массивами, оставляя `ArrayBuffer` «под капотом». Но мы можем в любой момент получить к нему доступ с помощью `.buffer` и при необходимости создать другое представление.

Существуют ещё 2 дополнительных термина, которые используются в описаниях методов, работающих с бинарными данными:

* `ArrayBufferView` – это общее название для представлений всех типов.
* `BufferSource` – это общее название для `ArrayBuffer` или `ArrayBufferView`.

Мы встретимся с ними в следующих главах. `BufferSource` встречается очень часто и означает «бинарные данные в любом виде» – `ArrayBuffer` или его представление.


## TextDecoder и TextEncoder

Что если бинарные данные фактически являются строкой? Например, мы получили файл с текстовыми данными.

Встроенный объект TextDecoder позволяет декодировать данные из бинарного буфера в обычную строку.

Для этого прежде всего нам нужно создать сам декодер:
```javascript
let decoder = new TextDecoder([label], [options]);
```

* `label` – тип кодировки, utf-8 используется по умолчанию, но также поддерживаются big5, windows-1251 и многие другие.
* `options` – объект с дополнительными настройками:
		** fatal – boolean, если значение true, тогда генерируется ошибка для невалидных (не декодируемых) символов, в ином случае (по умолчанию) они заменяются символом \uFFFD.
		** ignoreBOM – boolean, если значение true, тогда игнорируется BOM (дополнительный признак, определяющий порядок следования байтов), что необходимо крайне редко.

…и после использовать его метод `decode`:
```javascript
let str = decoder.decode([input], [options]);
```

* input – бинарный буфер (BufferSource) для декодирования.
* options – объект с дополнительными настройками:
		** stream – true для декодирования потока данных, при этом decoder вызывается вновь и вновь для каждого следующего фрагмента данных. В этом случае многобайтовый символ может иногда быть разделён и попасть в разные фрагменты данных. Это опция указывает TextDecoder запомнить символ, на котором остановился процесс, и декодировать его со следующим фрагментом.
Например:
```javascript
let uint8Array = new Uint8Array([72, 101, 108, 108, 111]);

alert( new TextDecoder().decode(uint8Array) ); // Hello

let uint8Array = new Uint8Array([228, 189, 160, 229, 165, 189]);

alert( new TextDecoder().decode(uint8Array) ); // 你好
```

Мы можем декодировать часть бинарного массива, создав подмассив:
```javascript
let uint8Array = new Uint8Array([0, 72, 101, 108, 108, 111, 0]);

// Возьмём строку из середины массива
// Также обратите внимание, что это создаёт только новое представление без копирования самого массива.
// Изменения в содержимом созданного подмассива повлияют на исходный массив и наоборот.
let binaryString = uint8Array.subarray(1, -1);

alert( new TextDecoder().decode(binaryString) ); // Hello
```

TextEncoder

TextEncoder поступает наоборот – кодирует строку в бинарный массив.

Имеет следующий синтаксис:
```javascript
let encoder = new TextEncoder();
```
Поддерживается только кодировка «utf-8».

Кодировщик имеет следующие два метода:

* `encode(str)` – возвращает бинарный массив Uint8Array, содержащий закодированную строку.
* `encodeInto(str, destination)` – кодирует строку (str) и помещает её в `destination`, который должен быть экземпляром `Uint8Array`.

```javascript
let encoder = new TextEncoder();
let uint8Array = encoder.encode("Hello");
alert(uint8Array); // 72,101,108,108,111
```

## Blob

ArrayBuffer и бинарные массивы являются частью ECMA-стандарта и, соответственно, частью JavaScript.

Кроме того, в браузере имеются дополнительные высокоуровневые объекты, описанные в File API.

Объект Blob состоит из необязательной строки type (обычно MIME-тип) и blobParts – последовательности других объектов Blob, строк и BufferSource.

		[type]						[blobParts]
				   _____________________|________________
Blob = image/png + [blob1 | blob2 | ... | str | buffer]

Благодаря `type` мы можем загружать и скачивать Blob-объекты, где `type` естественно становится `Content-Type` в сетевых запросах.

Конструктор имеет следующий синтаксис:
```javascript
new Blob(blobParts, options);
```


* `blobParts` – массив значений `Blob/BufferSource/String`.
* `options` – необязательный объект с дополнительными настройками:
		** `type` – тип объекта, обычно MIME-тип, например: image/png,
		** `endings` – если указан, то окончания строк создаваемого Blob будут изменены в соответствии с текущей операционной системой (\r\n или \n). По умолчанию "transparent" (ничего не делать), но также может быть "native" (изменять).

Например:
```javascript
// создадим Blob из строки
let blob = new Blob(["<html>…</html>"], {type: 'text/html'});
// обратите внимание: первый аргумент должен быть массивом [...]

// создадим Blob из типизированного массива и строк
let hello = new Uint8Array([72, 101, 108, 108, 111]); // "hello" в бинарной форме

let blob = new Blob([hello, ' ', 'world'], {type: 'text/plain'});
```

Мы можем получить срез `Blob`, используя:
```javascript
blob.slice([byteStart], [byteEnd], [contentType]);
```

* `byteStart` – стартовая позиция байта, по умолчанию 0.
* `byteEnd` – последний байт, по умолчанию до конца.
* `contentType` – тип type создаваемого Blob-объекта, по умолчанию такой же, как и исходный.

Аргументы – как в `array.slice`, отрицательные числа также разрешены.


**Blob не изменяем (immutable)**

Мы не можем изменять данные напрямую в `Blob`, но мы можем делать срезы и создавать новый `Blob` на их основе, объединять несколько объектов в новый и так далее.

Это поведение аналогично JavaScript-строке: мы не можем изменить символы в строке, но мы можем создать новую исправленную строку на базе имеющейся.

### Blob как URL

Blob может быть использован как URL для <a>, <img> или других тегов, для показа содержимого.

Давайте начнём с простого примера. При клике на ссылку мы загружаем динамически генерируемый Blob с hello world содержимым как файл:

<!-- download атрибут указывает браузеру делать загрузку вместо навигации -->
<a download="hello.txt" href='#' id="link">Загрузить</a>

<script>
let blob = new Blob(["Hello, world!"], {type: 'text/plain'});

link.href = URL.createObjectURL(blob);
</script>

Мы также можем создать ссылку динамически, используя только JavaScript, и эмулировать на ней клик, используя link.click(), тогда загрузка начнётся автоматически.

Далее простой пример создания «на лету» и загрузки Blob-объекта, без использования HTML:
```javascript
let link = document.createElement('a');
link.download = 'hello.txt';

let blob = new Blob(['Hello, world!'], {type: 'text/plain'});

link.href = URL.createObjectURL(blob);

link.click();

URL.revokeObjectURL(link.href);
```

URL.createObjectURL берёт Blob и создаёт уникальный URL для него в формате blob:<origin>/<uuid>.

Вот как выглядит сгенерированный URL:

blob:https://javascript.info/1e67e00e-860d-40a5-89ae-6ab0cbee6273

Браузер для каждого URL, сгенерированного через `URL.createObjectURL`, сохраняет внутреннее соответствие URL → Blob. Так образом, такие URL короткие, но дают доступ к большому объекту Blob.

Сгенерированный url действителен, только пока текущий документ открыт. Это позволяет ссылаться на сгенерированный в нём Blob в <img>, <a> или в любом другом объекте, где ожидается url в качестве одного из параметров.

В данном случае возможен побочный эффект. Пока в карте соответствия существует ссылка на Blob, он находится в памяти. Браузер не может освободить память, занятую Blob-объектом.

Ссылка в карте соответствия автоматически удаляется при выгрузке документа, после этого также освобождается память. Но если приложение имеет длительный жизненный цикл, это может произойти не скоро. Таким образом, если мы создадим URL для Blob, он будет висеть в памяти, даже если в нём нет больше необходимости.

URL.revokeObjectURL(url) удаляет внутреннюю ссылку на объект, что позволяет удалить его (если нет другой ссылки) сборщику мусора, и память будет освобождена.

В последнем примере мы использовали Blob только единожды, для мгновенной загрузки, после мы сразу же вызвали URL.revokeObjectURL(link.href).

В предыдущем примере с кликабельной HTML-ссылкой мы не вызывали URL.revokeObjectURL(link.href), потому что это сделало бы ссылку недействительной. После удаления внутренней ссылки на Blob, URL больше не будет работать.


### Blob to base64

Альтернатива `URL.createObjectURL` – конвертация Blob-объекта в строку с кодировкой base64.

Эта кодировка представляет двоичные данные в виде строки с безопасными для чтения символами в ASCII-кодах от 0 до 64. И что более важно – мы можем использовать эту кодировку для «data-urls».

data url имеет форму data:[<mediatype>][;base64],<data>. Мы можем использовать такой url где угодно наряду с «обычным» url.

Например, смайлик:

<img src="data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7">

Браузер декодирует строку и показывает смайлик.

Для трансформации `Blob` в `base64` мы будем использовать встроенный в браузер объект типа `FileReader`. Он может читать данные из Blob в множестве форматов. В следующей главе мы рассмотрим это более глубоко.

Вот пример загрузки Blob при помощи base64:
```javascript
let link = document.createElement('a');
link.download = 'hello.txt';

let blob = new Blob(['Hello, world!'], {type: 'text/plain'});

let reader = new FileReader();
reader.readAsDataURL(blob); // конвертирует Blob в base64 и вызывает onload

reader.onload = function() {
  link.href = reader.result; // url с данными
  link.click();
};
```

Оба варианта могут быть использованы для создания URL с Blob. Но обычно `URL.createObjectURL(blob)` является более быстрым и безопасным.


`URL.createObjectURL(blob)`

* Нужно отзывать объект для освобождения памяти.
* Прямой доступ к Blob, без «кодирования/декодирования».

`Blob to data url`

* Нет необходимости что-либо отзывать.
* Потеря производительности и памяти при декодировании больших Blob-объектов.


Пример получения строки base64 из полученного по URL изображения (или другого файла):

```javascript
const getBase64FromUrl = async (url) => {
    try {
        let response = await fetch(url);
        if (!response.ok) {
            throw Error(`toDataUrl: Возникла проблема при получении данных из удаленного источника. Заголовки ответа: ${response.headers}`);
        }
        let blob = await response.blob();
        const reader = new FileReader();
        reader.readAsDataURL(blob); //вызывает onload после конвертации
        reader.onload = (event) => {
            let result = reader.result; //или используя event.target.result
            const base64 = result.split(',')[1]; // берем base64 из строки
            return base64;
        };

    } catch(e) {
        throw e;
    }

}
```

### Изображение в Blob

Мы можем создать Blob для изображения, части изображения или даже создать скриншот страницы. Что удобно для последующей загрузки куда-либо.

Операции с изображениями выполняются через элемент <canvas>:

1. Для отрисовки изображения (или его части) на холсте (canvas) используется canvas.drawImage.
2. Вызов canvas-метода .toBlob(callback, format, quality) создаёт Blob и вызывает функцию callback при завершении.

В примере ниже изображение просто копируется, но мы можем взять его часть или трансформировать его на `canvas` перед созданием Blob:
```javascript
// берём любое изображение
let img = document.querySelector('img');

// создаём <canvas> того же размера
let canvas = document.createElement('canvas');
canvas.width = img.clientWidth;
canvas.height = img.clientHeight;

let context = canvas.getContext('2d');

// копируем изображение в  canvas (метод позволяет вырезать часть изображения)
context.drawImage(img, 0, 0);
// мы можем вращать изображение при помощи context.rotate() и делать множество других преобразований

// toBlob является асинхронной операцией, для которой callback-функция вызывается при завершении
canvas.toBlob(function(blob) {
  // после того, как Blob создан, загружаем его
  let link = document.createElement('a');
  link.download = 'example.png';

  link.href = URL.createObjectURL(blob);
  link.click();

  // удаляем внутреннюю ссылку на Blob, что позволит браузеру очистить память
  URL.revokeObjectURL(link.href);
}, 'image/png');
```

Или если вы предпочитаете async/await вместо колбэка:
```javascript
let blob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));
```

Для создания скриншота страницы мы можем использовать такую библиотеку, как https://github.com/niklasvh/html2canvas. Всё, что она делает, это просто проходит страницу и отрисовывает её в <canvas>. После этого мы может получить Blob одним из вышеуказанных способов.


Из Blob в ArrayBuffer

Конструктор Blob позволяет создать Blob-объект практически из чего угодно, включая `BufferSource`.

Но если нам нужна производительная низкоуровневая обработка, мы можем использовать `ArrayBuffer` из `FileReader`:
```javascript
// получаем arrayBuffer из Blob
let fileReader = new FileReader();

fileReader.readAsArrayBuffer(blob);

fileReader.onload = function(event) {
  let arrayBuffer = fileReader.result;
};
```

**Итого**

В то время как `ArrayBuffer, Uint8Array` и другие `BufferSource` являются «бинарными данными», Blob представляет собой «бинарные данные с типом».

Это делает Blob удобным для операций загрузки/выгрузки данных, которые так часто используются в браузере.

Методы, которые выполняют сетевые запросы, такие как `XMLHttpRequest`, `fetch` и подобные, могут изначально работать с Blob так же, как и с другими объектами, представляющими двоичные данные.

Мы можем легко конвертировать Blob в низкоуровневые бинарные типы данных и обратно:

* Мы можем создать Blob из типизированного массива, используя конструктор `new Blob(...)`.
* Мы можем обратно создать `ArrayBuffer` из `Blob`, используя `FileReader`, а затем создать его представление для низкоуровневых операций.


## File и FileReader

Объект `File` наследуется от объекта `Blob` и обладает возможностями по взаимодействию с файловой системой.

Есть два способа его получить.

Во-первых, есть конструктор, похожий на `Blob`:
```javascript
new File(fileParts, fileName, [options])
```

* `fileParts` – массив значений Blob/BufferSource/строки.
* `fileName` – имя файла, строка.
* `options` – необязательный объект со свойством:
		** `lastModified` – дата последнего изменения в формате таймстамп (целое число).


Во-вторых, чаще всего мы получаем файл из <input type="file"> или через перетаскивание с помощью мыши, или из других интерфейсов браузера. В этом случае файл получает эту информацию из ОС.

Так как `File` наследует от `Blob`, у объектов `File` есть те же свойства плюс:

* `name` – имя файла,
* `lastModified` – таймстамп для даты последнего изменения.

В этом примере мы получаем объект File из <input type="file">:

<input type="file" onchange="showFile(this)">

<script>
function showFile(input) {
  let file = input.files[0];

  alert(`File name: ${file.name}`); // например, my.png
  alert(`Last modified: ${file.lastModified}`); // например, 1552830408824
}
</script>

Через <input> можно выбрать несколько файлов, поэтому `input.files` – псевдомассив выбранных файлов. Здесь у нас только один файл, поэтому мы просто берём `input.files[0]`.

FileReader

`FileReader` объект, цель которого читать данные из Blob (и, следовательно, из File тоже).

Данные передаются при помощи событий, так как чтение с диска может занять время.

Конструктор:
```javascript
let reader = new FileReader(); // без аргументов
```

Основные методы:

* `readAsArrayBuffer(blob)` – считать данные как ArrayBuffer
* `readAsText(blob, [encoding])` – считать данные как строку (кодировка по умолчанию: utf-8)
* `readAsDataURL(blob)` – считать данные как base64-кодированный URL.
* `abort()` – отменить операцию.


Выбор метода для чтения зависит от того, какой формат мы предпочитаем, как мы хотим далее использовать данные.

* `readAsArrayBuffer` – для бинарных файлов, для низкоуровневой побайтовой работы с бинарными данными. Для высокоуровневых операций у File есть свои методы, унаследованные от Blob, например, slice, мы можем вызвать их напрямую.
* `readAsText` – для текстовых файлов, когда мы хотим получить строку.
* `readAsDataURL` – когда мы хотим использовать данные в src для img или другого тега. Есть альтернатива – можно не читать файл, а вызвать `URL.createObjectURL(file)`, детали в главе `Blob`.

В процессе чтения происходят следующие события:

* loadstart – чтение начато.
* progress – срабатывает во время чтения данных.
* load – нет ошибок, чтение окончено.
* abort – вызван abort().
* error – произошла ошибка.
* loadend – чтение завершено (успешно или нет).

Когда чтение закончено, мы сможем получить доступ к его результату следующим образом:

* `reader.result` результат чтения (если оно успешно)
* `reader.error` объект ошибки (при неудаче).

Наиболее часто используемые события – это, конечно же, load и error.

Вот пример чтения файла:

<input type="file" onchange="readFile(this)">

<script>
function readFile(input) {
  let file = input.files[0];

  let reader = new FileReader();

  reader.readAsText(file);

  reader.onload = function() {
    console.log(reader.result);
  };

  reader.onerror = function() {
    console.log(reader.error);
  };

}
</script>


Пример работы с blob с помощью fetch

```javascript
let response = await fetch('/article/fetch/logo-fetch.svg');

let blob = await response.blob(); // скачиваем как Blob-объект

// создаём <img>
let img = document.createElement('img');
img.style = 'position:fixed;top:10px;left:10px;width:100px';
document.body.append(img);

// выводим на экран
img.src = URL.createObjectURL(blob);

setTimeout(() => { // прячем через три секунды
  img.remove();
  URL.revokeObjectURL(img.src);
}, 3000);
```

# Объекты URL

Встроенный класс `URL` предоставляет удобный интерфейс для создания и разбора URL-адресов.

Нет сетевых методов, которые требуют именно объект `URL`, обычные строки вполне подходят. Так что, технически, мы не обязаны использовать `URL`. Но иногда он может быть весьма удобным.

## Создание URL

Синтаксис создания нового объекта `URL`: `new URL(url, [base])`


* url – полный URL-адрес или только путь, если указан второй параметр,
* base – необязательный «базовый» URL: если указан и аргумент url содержит только путь, то адрес будет создан относительно него (пример ниже).

Например:
```javascript
let url = new URL('https://javascript.info/profile/admin');
```

Эти два URL одинаковы:
```javascript
let url1 = new URL('https://javascript.info/profile/admin');
let url2 = new URL('/profile/admin', 'https://javascript.info');

alert(url1); // https://javascript.info/profile/admin
alert(url2); // https://javascript.info/profile/admin
```

Можно легко создать новый URL по пути относительно существующего URL-адреса:
```javascript
let url = new URL('https://javascript.info/profile/admin');
let newUrl = new URL('tester', url);

alert(newUrl); // https://javascript.info/profile/tester
```

Объект URL даёт доступ к компонентам URL, поэтому это отличный способ «разобрать» URL-адрес, например:
```javascript
let url = new URL('https://javascript.info/url');

alert(url.protocol); // https:
alert(url.host);     // javascript.info
alert(url.pathname); // /url
```



## Кодирование в строках

Раньше, до того как появились объекты `URL`, люди использовали для URL-адресов обычные строки.

Сейчас `URL` часто удобнее, но строки всё ещё можно использовать. Во многих случаях код с ними короче.

Однако, если мы используем строку, то надо самим позаботиться о кодировании специальных символов.

Для этого есть встроенные функции:

* `encodeURI` – кодирует URL-адрес целиком.
* `decodeURI` – декодирует URL-адрес целиком.
* `encodeURIComponent` – кодирует компонент URL, например, параметр, хеш, имя пути и т.п.
* `decodeURIComponent` – декодирует компонент URL.


* `encodeURI` кодирует только символы, полностью запрещённые в URL.
* `encodeURIComponent` кодирует эти же символы плюс, в дополнение к ним, символы #, $, &, +, ,, /, :, ;, =, ? и @.

Так что для URL целиком можно использовать `encodeURI`:
```javascript
let url = encodeURI('http://site.com/привет');

alert(url); // http://site.com/%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82
```

# Хранилища

Краткие сведения. Обычно браузером используется 4 типа хранилищ для временного/относительно постоянного хранения произвольных данных:

1. cookie файлы для хранения произвольных текстовых данных в текстовом файле
2. сессионное хранилище хранит данные пока в браузере открыта текущая страница, но сохраняет при обновлении
3. локальное хранилище хранит данные неопределенно долгое время
4. `IndexedDB` это встроенная база данных

Сессионное и локальное хранилища являются экземпляром класса `Storage`.



## Работа с локальным хранилищем

Чтобы начать работу к локальному хранилищу надо обратиться через глобальный объект `window`:

```javascript
if (window.localStorage) {

	//работаем с локальным хранилищем

} else {
	//браузер не поддерживает локальное хранилище
}
```

Объекты хранилища `localStorage` и `sessionStorage` предоставляют одинаковые методы и свойства:

* `setItem(key, value)` – сохранить пару ключ/значение.
* `getItem(key)` – получить данные по ключу key.
* `removeItem(key)` – удалить данные с ключом key.
* `clear()` – удалить всё.
* `key(index)` – получить ключ на заданной позиции.
* `length` – количество элементов в хранилище.


Основные особенности `localStorage`:

* Этот объект один на все вкладки и окна в рамках источника (один и тот же домен/протокол/порт).
* Данные не имеют срока давности, по которому истекают и удаляются. Сохраняются после перезапуска браузера и даже ОС.

Объект `localStorage` доступен всем окнам из одного источника, поэтому, если мы устанавливаем данные в одном окне, изменения становятся видимыми в другом.


пример записи в локальное хранилище:
```javascript
const setLocalStorageItem = (key, item) => {
//item obj
    if (window.localStorage && key) {
        console.log(`Saving to local storage data`);
        const local = window.localStorage;
        local.setItem(key, JSON.stringify(item));
    } else {
        return;
    }
}
```
пример чтения из локального хранилища:

```javascript
const getLocalStorageItem = (key) => {
//item obj
    if (window.localStorage && key) {
        console.log(`Reading data from local storage`);
        const local = window.localStorage;
        const result = local.getItem(key);
        return result;
    } else {
        return;
    }
}
```

Также можно получать/записывать данные, как в обычный объект:
```javascript
// установить значение для ключа
localStorage.test = 2;

// получить значение по ключу
alert( localStorage.test ); // 2

// удалить ключ
delete localStorage.test;
```

Также допустимо обращаться к локальному хранилищу без глобального объекта `window`:
```javascript
localStorage.setItem('test', 1);
```

Ключ и значение должны быть *строками*.

Если мы используем любой другой тип, например число или объект, то он автоматически преобразуется в строку:
```javascript
sessionStorage.user = {name: "John"};
alert(sessionStorage.user); // [object Object]
```

## sessionStorage

Объект sessionStorage используется гораздо реже, чем `localStorage`.

Свойства и методы такие же, но есть существенные ограничения:

* `sessionStorage` существует только в рамках текущей вкладки браузера.
        ** Другая вкладка с той же страницей будет иметь другое хранилище.
        ** Но оно разделяется между ифреймами на той же вкладке (при условии, что они из одного и того же источника).
* Данные продолжают существовать после перезагрузки страницы, но не после закрытия/открытия вкладки.




## Куки, document.cookie

Куки – это небольшие строки данных, которые хранятся непосредственно в браузере. Они являются частью HTTP-протокола, определённого в спецификации RFC 6265.

Куки обычно устанавливаются веб-сервером при помощи заголовка Set-Cookie. Затем браузер будет автоматически добавлять их в (почти) каждый запрос на тот же домен при помощи заголовка Cookie.

Один из наиболее частых случаев использования куки – это аутентификация:

1. При входе на сайт сервер отсылает в ответ HTTP-заголовок Set-Cookie для того, чтобы установить куки со специальным уникальным идентификатором сессии («session identifier»).
2. Во время следующего запроса к этому же домену браузер посылает на сервер HTTP-заголовок Cookie.
3. Таким образом, сервер понимает, кто сделал запрос.


Мы также можем получить доступ к куки непосредственно из браузера, используя свойство `document.cookie`.

Куки имеют множество особенностей и тонкостей в использовании, и в этой главе мы подробно с ними разберёмся.

### Чтение из document.cookie

Чтобы проверить текущие куки на конкретном сайте достаточно вызвать `document.cookie`.
Значение `document.cookie` состоит из пар ключ=значение, разделённых ;. Каждая пара представляет собой отдельное куки.

Чтобы найти определённое куки, достаточно разбить строку из `document.cookie` по ;, и затем найти нужный ключ. Для этого мы можем использовать как регулярные выражения, так и функции для обработки массивов.

### Запись в document.cookie

Мы можем писать в `document.cookie`. Но это не просто данные, а акcессор (геттер/сеттер). Присваивание обрабатывается особым образом.

Запись в `document.cookie` обновит только упомянутые в ней куки, но при этом не затронет все остальные.

Например, этот вызов установит куки с именем user и значением John:
```javascript
document.cookie = "user=John"; // обновляем только куки с именем 'user'
alert(document.cookie); // показываем все куки
```

Если вы запустите этот код, то, скорее всего, увидите множество куки. Это происходит, потому что операция document.cookie= перезапишет не все куки, а лишь куки с вышеупомянутым именем user.

Технически, и имя и значение куки могут состоять из любых символов, для правильного форматирования следует использовать встроенную функцию `encodeURIComponent`:
```javascript
// специальные символы (пробелы), требуется кодирование
let name = "my name";
let value = "John Smith"

// кодирует в my%20name=John%20Smith
document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);

alert(document.cookie); // ...; my%20name=John%20Smith
```
Существует несколько ограничений:

* После encodeURIComponent пара `name=value` не должна занимать более 4Кб. Таким образом, мы не можем хранить в куки большие данные.
* Общее количество куки на один домен ограничивается примерно 20+. Точное ограничение зависит от конкретного браузера.

У куки есть ряд настроек, многие из которых важны и должны быть установлены.

Эти настройки указываются после пары ключ=значение и отделены друг от друга разделителем ;, вот так:
```javascript
document.cookie = "user=John; path=/; expires=Tue, 19 Jan 2038 03:14:07 GMT"
```

## Событие storage

Когда обновляются данные в `localStorage` или `sessionStorage`, генерируется событие storage со следующими свойствами:

* `key` – ключ, который обновился (null, если вызван .clear()).
* `oldValue` – старое значение (null, если ключ добавлен впервые).
* `newValue` – новое значение (null, если ключ был удалён).
* `url` – url документа, где произошло обновление.
* `storageArea` – объект localStorage или sessionStorage, где произошло обновление.

**Важно**: событие срабатывает на всех остальных объектах window, где доступно хранилище, кроме того окна, которое его вызвало.

Давайте уточним.

Представьте, что у вас есть два окна с одним и тем же сайтом. Хранилище localStorage разделяется между ними.

Вы можете открыть эту страницу в двух окнах браузера, чтобы проверить приведённый ниже код.

Теперь, если оба окна слушают window.onstorage, то каждое из них будет реагировать на обновления, произошедшие в другом окне.
```javascript
// срабатывает при обновлениях, сделанных в том же хранилище из других документов
window.onstorage = event => {
  if (event.key != 'now') return;
  alert(event.key + ':' + event.newValue + " at " + event.url);
};

localStorage.setItem('now', Date.now());
```

Обратите внимание, что событие также содержит: `event.url` – url-адрес документа, в котором данные обновились.

Также `event.storageArea` содержит объект хранилища – событие одно и то же для `sessionStorage` и `localStorage`, поэтому `event.storageArea` ссылается на то хранилище, которое было изменено. Мы можем захотеть что-то записать в ответ на изменения.

Это позволяет разным окнам одного источника обмениваться сообщениями.

Современные браузеры также поддерживают Broadcast channel API специальный API для связи между окнами одного источника, он более полнофункциональный, но менее поддерживаемый. Существуют библиотеки (полифилы), которые эмулируют это API на основе localStorage и делают его доступным везде.

## IndexedDB

IndexedDB – это встроенная база данных, более мощная, чем localStorage.

* Хранилище ключей/значений: доступны несколько типов ключей, а значения могут быть (почти) любыми.
* Поддерживает транзакции для надёжности.
* Поддерживает запросы в диапазоне ключей и индексы.
* Позволяет хранить больше данных, чем localStorage.

Для традиционных клиент-серверных приложений эта мощность обычно чрезмерна. `IndexedDB` предназначена для оффлайн приложений, можно совмещать с `ServiceWorkers` и другими технологиями.

Интерфейс для IndexedDB, описанный в спецификации https://www.w3.org/TR/IndexedDB, основан на событиях.

Мы также можем использовать async/await с помощью обёртки, которая основана на промисах, например https://github.com/jakearchibald/idb. Это очень удобно, но обёртка не идеальна, она не может полностью заменить события. Поэтому мы начнём с событий, а затем, когда разберёмся в IndexedDB, рассмотрим и обёртку.


### Открыть базу данных

Для начала работы с `IndexedDB` нужно открыть базу данных.

Синтаксис:
```javascript
let openRequest = indexedDB.open(name, version);
```


* name – название базы данных, строка.
* version – версия базы данных, положительное целое число, по умолчанию 1 (объясняется ниже).


У нас может быть множество баз данных с различными именами, но все они существуют в контексте текущего источника (домен/протокол/порт). Разные сайты не могут получить доступ к базам данных друг друга.

После этого вызова необходимо назначить обработчик событий для объекта `openRequest`:

* success: база данных готова к работе, готов «объект базы данных» openRequest.result, его следует использовать для дальнейших вызовов.
* error: не удалось открыть базу данных.
* upgradeneeded: база открыта, но её схема устарела (см. ниже).

IndexedDB имеет встроенный механизм «версионирования схемы», который отсутствует в серверных базах данных.

В отличие от серверных баз данных, `IndexedDB` работает на стороне клиента, в браузере, и у нас нет прямого доступа к данным. Но когда мы публикуем новую версию нашего приложения, возможно, нам понадобится обновить базу данных.

Если локальная версия базы данных меньше, чем версия, определённая в open, то сработает специальное событие upgradeneeded, и мы сможем сравнить версии и обновить структуры данных по мере необходимости.

Это событие также сработает, если базы данных ещё не существует, так что в этом обработчике мы можем выполнить инициализацию.

Например, когда мы впервые публикуем наше приложение, мы открываем базу данных с версией 1 и выполняем инициализацию в обработчике `upgradeneeded`:
```javascript
let openRequest = indexedDB.open("store", 1);

openRequest.onupgradeneeded = function() {
  // срабатывает, если на клиенте нет базы данных
  // ...выполнить инициализацию...
};

openRequest.onerror = function() {
  console.error("Error", openRequest.error);
};

openRequest.onsuccess = function() {
  let db = openRequest.result;
  // продолжить работу с базой данных, используя объект db
};
```